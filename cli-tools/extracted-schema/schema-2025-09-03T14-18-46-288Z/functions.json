[
  {
    "schema_name": "public",
    "function_name": "_ensure_policy",
    "arguments": "in_schema text, in_table text, in_name text, in_cmd text, in_roles text, in_using text, in_check text",
    "return_type": "void",
    "function_definition": "CREATE OR REPLACE FUNCTION public._ensure_policy(in_schema text, in_table text, in_name text, in_cmd text, in_roles text, in_using text, in_check text)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_policies\n    WHERE schemaname=in_schema AND tablename=in_table AND policyname=in_name\n  ) THEN\n    EXECUTE format(\n      'CREATE POLICY %I ON %I.%I FOR %s TO %s %s %s;',\n      in_name, in_schema, in_table, in_cmd, in_roles,\n      CASE WHEN in_using IS NOT NULL THEN 'USING ('||in_using||')' ELSE '' END,\n      CASE WHEN in_check IS NOT NULL THEN 'WITH CHECK ('||in_check||')' ELSE '' END\n    );\n  END IF;\nEND\n$function$\n",
    "source_code": "\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_policies\n    WHERE schemaname=in_schema AND tablename=in_table AND policyname=in_name\n  ) THEN\n    EXECUTE format(\n      'CREATE POLICY %I ON %I.%I FOR %s TO %s %s %s;',\n      in_name, in_schema, in_table, in_cmd, in_roles,\n      CASE WHEN in_using IS NOT NULL THEN 'USING ('||in_using||')' ELSE '' END,\n      CASE WHEN in_check IS NOT NULL THEN 'WITH CHECK ('||in_check||')' ELSE '' END\n    );\n  END IF;\nEND\n"
  },
  {
    "schema_name": "public",
    "function_name": "_touch_updated_at",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public._touch_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nBEGIN NEW.updated_at = now(); RETURN NEW; END $function$\n",
    "source_code": "\nBEGIN NEW.updated_at = now(); RETURN NEW; END "
  },
  {
    "schema_name": "public",
    "function_name": "apply_blocks_to_workout",
    "arguments": "p_daily_workout_id bigint",
    "return_type": "void",
    "function_definition": "CREATE OR REPLACE FUNCTION public.apply_blocks_to_workout(p_daily_workout_id bigint)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\ndeclare\n  blk record;\n  itm record;\n  seq_base int;\n  payload jsonb;\nbegin\n  -- Idempotent: clear any previously materialized rows\n  delete from public.daily_workout_movements\n   where daily_workout_id = p_daily_workout_id;\n\n  -- For each selected block (one per type), in display order\n  for blk in\n    select b.block_type, b.block_id, b.variant\n      from public.daily_workout_blocks b\n     where b.daily_workout_id = p_daily_workout_id\n     order by case b.block_type\n                when 'prep' then 1\n                when 'build' then 2\n                when 'capacity' then 3\n                else 4\n              end\n  loop\n    seq_base := case blk.block_type\n                  when 'prep' then 100\n                  when 'build' then 200\n                  when 'capacity' then 300\n                  else 400\n                end;\n\n    -- Pull items and movement defaults; select the chosen variant payload\n    for itm in\n      select\n        i.sequence,\n        i.movement_uuid,\n        (i.variants -> blk.variant)        as v_payload,\n        m.default_modifiers,\n        m.default_metrics,\n        m.default_sport_impact_vector,\n        m.default_module_impact_vector\n      from public.movement_block_items i\n      left join public.movements m on m.id = i.movement_uuid\n     where i.block_id = blk.block_id\n     order by i.sequence\n    loop\n      if itm.v_payload is null then\n        raise exception 'Block % item % is missing variant key %', blk.block_id, itm.sequence, blk.variant;\n      end if;\n\n      -- Merge prescription with movement defaults\n      payload :=\n        coalesce(itm.v_payload, '{}'::jsonb)\n        || coalesce(itm.default_modifiers, '{}'::jsonb)\n        || case when itm.default_metrics is not null\n                then jsonb_build_object('metrics', itm.default_metrics)\n                else '{}'::jsonb end\n        || case when itm.default_sport_impact_vector is not null\n                then jsonb_build_object('sport_vector', itm.default_sport_impact_vector)\n                else '{}'::jsonb end;\n\n      insert into public.daily_workout_movements\n        (daily_workout_id,\n         movement_id,              -- canonical uuid\n         sequence,\n         status,\n         assigned_intensity,\n         source_movement_id)\n      values\n        (p_daily_workout_id,\n         itm.movement_uuid,\n         seq_base + itm.sequence,\n         'pending',\n         payload,\n         itm.movement_uuid);\n    end loop;\n  end loop;\n\n  -- Enforce NOT NULL after successful materialization\n  alter table public.daily_workout_movements\n    alter column movement_id set not null;\nend\n$function$\n",
    "source_code": "\ndeclare\n  blk record;\n  itm record;\n  seq_base int;\n  payload jsonb;\nbegin\n  -- Idempotent: clear any previously materialized rows\n  delete from public.daily_workout_movements\n   where daily_workout_id = p_daily_workout_id;\n\n  -- For each selected block (one per type), in display order\n  for blk in\n    select b.block_type, b.block_id, b.variant\n      from public.daily_workout_blocks b\n     where b.daily_workout_id = p_daily_workout_id\n     order by case b.block_type\n                when 'prep' then 1\n                when 'build' then 2\n                when 'capacity' then 3\n                else 4\n              end\n  loop\n    seq_base := case blk.block_type\n                  when 'prep' then 100\n                  when 'build' then 200\n                  when 'capacity' then 300\n                  else 400\n                end;\n\n    -- Pull items and movement defaults; select the chosen variant payload\n    for itm in\n      select\n        i.sequence,\n        i.movement_uuid,\n        (i.variants -> blk.variant)        as v_payload,\n        m.default_modifiers,\n        m.default_metrics,\n        m.default_sport_impact_vector,\n        m.default_module_impact_vector\n      from public.movement_block_items i\n      left join public.movements m on m.id = i.movement_uuid\n     where i.block_id = blk.block_id\n     order by i.sequence\n    loop\n      if itm.v_payload is null then\n        raise exception 'Block % item % is missing variant key %', blk.block_id, itm.sequence, blk.variant;\n      end if;\n\n      -- Merge prescription with movement defaults\n      payload :=\n        coalesce(itm.v_payload, '{}'::jsonb)\n        || coalesce(itm.default_modifiers, '{}'::jsonb)\n        || case when itm.default_metrics is not null\n                then jsonb_build_object('metrics', itm.default_metrics)\n                else '{}'::jsonb end\n        || case when itm.default_sport_impact_vector is not null\n                then jsonb_build_object('sport_vector', itm.default_sport_impact_vector)\n                else '{}'::jsonb end;\n\n      insert into public.daily_workout_movements\n        (daily_workout_id,\n         movement_id,              -- canonical uuid\n         sequence,\n         status,\n         assigned_intensity,\n         source_movement_id)\n      values\n        (p_daily_workout_id,\n         itm.movement_uuid,\n         seq_base + itm.sequence,\n         'pending',\n         payload,\n         itm.movement_uuid);\n    end loop;\n  end loop;\n\n  -- Enforce NOT NULL after successful materialization\n  alter table public.daily_workout_movements\n    alter column movement_id set not null;\nend\n"
  },
  {
    "schema_name": "public",
    "function_name": "assign_program",
    "arguments": "p_user_id uuid, p_program_slug text, p_start_date date, p_day_offsets smallint[] DEFAULT ARRAY[0, 2, 4]",
    "return_type": "uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.assign_program(p_user_id uuid, p_program_slug text, p_start_date date, p_day_offsets smallint[] DEFAULT ARRAY[0, 2, 4])\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_role   text := current_setting('request.jwt.claim.role', true);\n  v_sub    text := current_setting('request.jwt.claim.sub',  true);\n  v_prog   record;\n  v_up_id  uuid;\nbegin\n  -- inputs\n  if p_day_offsets is null or array_length(p_day_offsets,1) < 3 then\n    raise exception 'p_day_offsets must be an array of length 3 (e.g., {0,2,4}).'\n      using errcode = '22023';\n  end if;\n\n  -- auth: allow service_role; otherwise caller must be the user\n  if coalesce(v_role,'') <> 'service_role' then\n    if v_sub is null or v_sub::uuid <> p_user_id then\n      raise exception 'not allowed: caller must be user %', p_user_id using errcode='42501';\n    end if;\n  end if;\n\n  -- program lookup\n  select id, name, version, weeks, workouts_per_week\n  into v_prog\n  from public.programs\n  where slug = p_program_slug\n  limit 1;\n\n  if not found then\n    raise exception 'program slug \"%\" not found', p_program_slug using errcode='02000';\n  end if;\n\n  -- create user_program\n  insert into public.user_programs (\n    user_id, program_id, program_slug_snapshot, program_name_snapshot,\n    template_version_snapshot, start_date, workouts_per_week, status\n  )\n  values (\n    p_user_id, v_prog.id, p_program_slug, v_prog.name,\n    v_prog.version, p_start_date, v_prog.workouts_per_week, 'planned'\n  )\n  returning id into v_up_id;\n\n  -- workouts, blocks, items (with progression)\n  with t_workouts as (\n    select w.week_index, wo.day_index, wo.title, wo.id as program_workout_id\n    from public.program_workouts wo\n    join public.program_weeks   w on w.id = wo.week_id\n    where w.program_id = v_prog.id\n  ),\n  ins_uw as (\n    insert into public.user_workouts (\n      user_program_id, week_index, day_index, scheduled_date, title_snapshot, status\n    )\n    select\n      v_up_id,\n      tw.week_index,\n      tw.day_index,\n      p_start_date\n        + (((tw.week_index - 1) * 7) + p_day_offsets[tw.day_index])::int,\n      tw.title,\n      'planned'\n    from t_workouts tw\n    returning id, week_index, day_index\n  ),\n  block_source as (\n    select\n      uw.id as user_workout_id,\n      uw.week_index,\n      pwb.sequence,\n      pwb.movement_block_id\n    from ins_uw uw\n    join public.program_weeks w\n      on w.program_id = v_prog.id\n     and w.week_index = uw.week_index\n    join public.program_workouts wo\n      on wo.week_id = w.id\n     and wo.day_index = uw.day_index\n    join public.program_workout_blocks pwb\n      on pwb.program_workout_id = wo.id\n  ),\n  ins_uwb as (\n    insert into public.user_workout_blocks (\n      user_workout_id, sequence, movement_block_id, block_name_snapshot, block_type_label_snapshot\n    )\n    select\n      bs.user_workout_id,\n      bs.sequence,\n      bs.movement_block_id,\n      mb.name,\n      bt.label\n    from block_source bs\n    join public.movement_blocks mb on mb.id = bs.movement_block_id\n    join public.block_types    bt on bt.id = mb.block_type_id\n    returning id, user_workout_id, movement_block_id, block_type_label_snapshot\n  )\n  insert into public.user_block_items (\n    user_workout_block_id, sequence, movement_id, movement_name_snapshot,\n    planned_dose, base_dose_snapshot\n  )\n  select\n    uwb.id as user_workout_block_id,\n    mbi.sequence,\n    mv.id as movement_id,\n    mv.name as movement_name_snapshot,\n    -- progression applied here\n    public.progress_dose(uw.week_index::smallint, uwb.block_type_label_snapshot::text, mbi.default_dose) as planned_dose,\n    mbi.default_dose as base_dose_snapshot\n  from ins_uwb uwb\n  join public.user_workouts uw        on uw.id = uwb.user_workout_id\n  join public.movement_block_items mbi on mbi.block_id = uwb.movement_block_id\n  join public.movements mv             on mv.id = mbi.movement_id;\n\n  return v_up_id;\nend;\n$function$\n",
    "source_code": "\ndeclare\n  v_role   text := current_setting('request.jwt.claim.role', true);\n  v_sub    text := current_setting('request.jwt.claim.sub',  true);\n  v_prog   record;\n  v_up_id  uuid;\nbegin\n  -- inputs\n  if p_day_offsets is null or array_length(p_day_offsets,1) < 3 then\n    raise exception 'p_day_offsets must be an array of length 3 (e.g., {0,2,4}).'\n      using errcode = '22023';\n  end if;\n\n  -- auth: allow service_role; otherwise caller must be the user\n  if coalesce(v_role,'') <> 'service_role' then\n    if v_sub is null or v_sub::uuid <> p_user_id then\n      raise exception 'not allowed: caller must be user %', p_user_id using errcode='42501';\n    end if;\n  end if;\n\n  -- program lookup\n  select id, name, version, weeks, workouts_per_week\n  into v_prog\n  from public.programs\n  where slug = p_program_slug\n  limit 1;\n\n  if not found then\n    raise exception 'program slug \"%\" not found', p_program_slug using errcode='02000';\n  end if;\n\n  -- create user_program\n  insert into public.user_programs (\n    user_id, program_id, program_slug_snapshot, program_name_snapshot,\n    template_version_snapshot, start_date, workouts_per_week, status\n  )\n  values (\n    p_user_id, v_prog.id, p_program_slug, v_prog.name,\n    v_prog.version, p_start_date, v_prog.workouts_per_week, 'planned'\n  )\n  returning id into v_up_id;\n\n  -- workouts, blocks, items (with progression)\n  with t_workouts as (\n    select w.week_index, wo.day_index, wo.title, wo.id as program_workout_id\n    from public.program_workouts wo\n    join public.program_weeks   w on w.id = wo.week_id\n    where w.program_id = v_prog.id\n  ),\n  ins_uw as (\n    insert into public.user_workouts (\n      user_program_id, week_index, day_index, scheduled_date, title_snapshot, status\n    )\n    select\n      v_up_id,\n      tw.week_index,\n      tw.day_index,\n      p_start_date\n        + (((tw.week_index - 1) * 7) + p_day_offsets[tw.day_index])::int,\n      tw.title,\n      'planned'\n    from t_workouts tw\n    returning id, week_index, day_index\n  ),\n  block_source as (\n    select\n      uw.id as user_workout_id,\n      uw.week_index,\n      pwb.sequence,\n      pwb.movement_block_id\n    from ins_uw uw\n    join public.program_weeks w\n      on w.program_id = v_prog.id\n     and w.week_index = uw.week_index\n    join public.program_workouts wo\n      on wo.week_id = w.id\n     and wo.day_index = uw.day_index\n    join public.program_workout_blocks pwb\n      on pwb.program_workout_id = wo.id\n  ),\n  ins_uwb as (\n    insert into public.user_workout_blocks (\n      user_workout_id, sequence, movement_block_id, block_name_snapshot, block_type_label_snapshot\n    )\n    select\n      bs.user_workout_id,\n      bs.sequence,\n      bs.movement_block_id,\n      mb.name,\n      bt.label\n    from block_source bs\n    join public.movement_blocks mb on mb.id = bs.movement_block_id\n    join public.block_types    bt on bt.id = mb.block_type_id\n    returning id, user_workout_id, movement_block_id, block_type_label_snapshot\n  )\n  insert into public.user_block_items (\n    user_workout_block_id, sequence, movement_id, movement_name_snapshot,\n    planned_dose, base_dose_snapshot\n  )\n  select\n    uwb.id as user_workout_block_id,\n    mbi.sequence,\n    mv.id as movement_id,\n    mv.name as movement_name_snapshot,\n    -- progression applied here\n    public.progress_dose(uw.week_index::smallint, uwb.block_type_label_snapshot::text, mbi.default_dose) as planned_dose,\n    mbi.default_dose as base_dose_snapshot\n  from ins_uwb uwb\n  join public.user_workouts uw        on uw.id = uwb.user_workout_id\n  join public.movement_block_items mbi on mbi.block_id = uwb.movement_block_id\n  join public.movements mv             on mv.id = mbi.movement_id;\n\n  return v_up_id;\nend;\n"
  },
  {
    "schema_name": "public",
    "function_name": "assign_program_self",
    "arguments": "p_program_slug text, p_start_date date, p_day_offsets smallint[] DEFAULT ARRAY[0, 2, 4]",
    "return_type": "uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.assign_program_self(p_program_slug text, p_start_date date, p_day_offsets smallint[] DEFAULT ARRAY[0, 2, 4])\n RETURNS uuid\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\n  select public.assign_program(\n    auth.uid(),          -- uses the caller’s JWT\n    p_program_slug,\n    p_start_date,\n    p_day_offsets\n  );\n$function$\n",
    "source_code": "\n  select public.assign_program(\n    auth.uid(),          -- uses the caller’s JWT\n    p_program_slug,\n    p_start_date,\n    p_day_offsets\n  );\n"
  },
  {
    "schema_name": "public",
    "function_name": "assign_seed_blocks_and_materialize",
    "arguments": "p_daily_workout_id bigint, p_prep_variant text DEFAULT 'base'::text, p_build_variant text DEFAULT 'base'::text, p_capacity_variant text DEFAULT 'base'::text, p_finish_variant text DEFAULT 'base'::text, p_pick_strategy text DEFAULT 'random'::text",
    "return_type": "TABLE(block_type text, block_id uuid, variant text)",
    "function_definition": "CREATE OR REPLACE FUNCTION public.assign_seed_blocks_and_materialize(p_daily_workout_id bigint, p_prep_variant text DEFAULT 'base'::text, p_build_variant text DEFAULT 'base'::text, p_capacity_variant text DEFAULT 'base'::text, p_finish_variant text DEFAULT 'base'::text, p_pick_strategy text DEFAULT 'random'::text)\n RETURNS TABLE(block_type text, block_id uuid, variant text)\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nDECLARE\n  v_prep     uuid;\n  v_build    uuid;\n  v_capacity uuid;\n  v_finish   uuid;\nBEGIN\n  -- validate workout exists\n  PERFORM 1 FROM public.daily_workouts WHERE id = p_daily_workout_id;\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'daily_workouts.id % does not exist', p_daily_workout_id;\n  END IF;\n\n  -- validate variants\n  IF p_prep_variant NOT IN ('low_impact','base','advanced') THEN\n    RAISE EXCEPTION 'Invalid prep variant \"%\". Use low_impact|base|advanced.', p_prep_variant;\n  END IF;\n  IF p_build_variant NOT IN ('low_impact','base','advanced') THEN\n    RAISE EXCEPTION 'Invalid build variant \"%\". Use low_impact|base|advanced.', p_build_variant;\n  END IF;\n  IF p_capacity_variant NOT IN ('low_impact','base','advanced') THEN\n    RAISE EXCEPTION 'Invalid capacity variant \"%\". Use low_impact|base|advanced.', p_capacity_variant;\n  END IF;\n  IF p_finish_variant NOT IN ('low_impact','base','advanced') THEN\n    RAISE EXCEPTION 'Invalid finish variant \"%\". Use low_impact|base|advanced.', p_finish_variant;\n  END IF;\n\n  -- validate pick strategy\n  IF p_pick_strategy NOT IN ('random','first') THEN\n    RAISE EXCEPTION 'Invalid pick strategy \"%\". Use random|first.', p_pick_strategy;\n  END IF;\n\n  -- pick one block per type from the seed set (QUALIFY column with alias \"b\")\n  SELECT id INTO v_prep\n  FROM public.movement_blocks b\n  WHERE b.notes='seed:blocks_v1' AND b.block_type='prep'\n  ORDER BY CASE WHEN p_pick_strategy='random' THEN random() ELSE b.id::text END\n  LIMIT 1;\n\n  SELECT id INTO v_build\n  FROM public.movement_blocks b\n  WHERE b.notes='seed:blocks_v1' AND b.block_type='build'\n  ORDER BY CASE WHEN p_pick_strategy='random' THEN random() ELSE b.id::text END\n  LIMIT 1;\n\n  SELECT id INTO v_capacity\n  FROM public.movement_blocks b\n  WHERE b.notes='seed:blocks_v1' AND b.block_type='capacity'\n  ORDER BY CASE WHEN p_pick_strategy='random' THEN random() ELSE b.id::text END\n  LIMIT 1;\n\n  SELECT id INTO v_finish\n  FROM public.movement_blocks b\n  WHERE b.notes='seed:blocks_v1' AND b.block_type='finish'\n  ORDER BY CASE WHEN p_pick_strategy='random' THEN random() ELSE b.id::text END\n  LIMIT 1;\n\n  IF v_prep IS NULL OR v_build IS NULL OR v_capacity IS NULL OR v_finish IS NULL THEN\n    RAISE EXCEPTION 'Seed blocks missing. Did you run the seed script (notes=seed:blocks_v1)?';\n  END IF;\n\n  -- upsert selections (one block per type per day)\n  INSERT INTO public.daily_workout_blocks (daily_workout_id, block_type, block_id, variant)\n  VALUES\n    (p_daily_workout_id, 'prep',     v_prep,     p_prep_variant),\n    (p_daily_workout_id, 'build',    v_build,    p_build_variant),\n    (p_daily_workout_id, 'capacity', v_capacity, p_capacity_variant),\n    (p_daily_workout_id, 'finish',   v_finish,   p_finish_variant)\n  ON CONFLICT (daily_workout_id, block_type) DO UPDATE\n  SET block_id = EXCLUDED.block_id,\n      variant  = EXCLUDED.variant;\n\n  -- snapshot movements for the day (idempotent)\n  PERFORM public.materialize_daily_workout_movements(p_daily_workout_id, true);\n\n  -- return what we assigned\n  RETURN QUERY\n  SELECT * FROM (VALUES\n    ('prep',     v_prep,     p_prep_variant),\n    ('build',    v_build,    p_build_variant),\n    ('capacity', v_capacity, p_capacity_variant),\n    ('finish',   v_finish,   p_finish_variant)\n  ) AS t(block_type, block_id, variant);\nEND $function$\n",
    "source_code": "\nDECLARE\n  v_prep     uuid;\n  v_build    uuid;\n  v_capacity uuid;\n  v_finish   uuid;\nBEGIN\n  -- validate workout exists\n  PERFORM 1 FROM public.daily_workouts WHERE id = p_daily_workout_id;\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'daily_workouts.id % does not exist', p_daily_workout_id;\n  END IF;\n\n  -- validate variants\n  IF p_prep_variant NOT IN ('low_impact','base','advanced') THEN\n    RAISE EXCEPTION 'Invalid prep variant \"%\". Use low_impact|base|advanced.', p_prep_variant;\n  END IF;\n  IF p_build_variant NOT IN ('low_impact','base','advanced') THEN\n    RAISE EXCEPTION 'Invalid build variant \"%\". Use low_impact|base|advanced.', p_build_variant;\n  END IF;\n  IF p_capacity_variant NOT IN ('low_impact','base','advanced') THEN\n    RAISE EXCEPTION 'Invalid capacity variant \"%\". Use low_impact|base|advanced.', p_capacity_variant;\n  END IF;\n  IF p_finish_variant NOT IN ('low_impact','base','advanced') THEN\n    RAISE EXCEPTION 'Invalid finish variant \"%\". Use low_impact|base|advanced.', p_finish_variant;\n  END IF;\n\n  -- validate pick strategy\n  IF p_pick_strategy NOT IN ('random','first') THEN\n    RAISE EXCEPTION 'Invalid pick strategy \"%\". Use random|first.', p_pick_strategy;\n  END IF;\n\n  -- pick one block per type from the seed set (QUALIFY column with alias \"b\")\n  SELECT id INTO v_prep\n  FROM public.movement_blocks b\n  WHERE b.notes='seed:blocks_v1' AND b.block_type='prep'\n  ORDER BY CASE WHEN p_pick_strategy='random' THEN random() ELSE b.id::text END\n  LIMIT 1;\n\n  SELECT id INTO v_build\n  FROM public.movement_blocks b\n  WHERE b.notes='seed:blocks_v1' AND b.block_type='build'\n  ORDER BY CASE WHEN p_pick_strategy='random' THEN random() ELSE b.id::text END\n  LIMIT 1;\n\n  SELECT id INTO v_capacity\n  FROM public.movement_blocks b\n  WHERE b.notes='seed:blocks_v1' AND b.block_type='capacity'\n  ORDER BY CASE WHEN p_pick_strategy='random' THEN random() ELSE b.id::text END\n  LIMIT 1;\n\n  SELECT id INTO v_finish\n  FROM public.movement_blocks b\n  WHERE b.notes='seed:blocks_v1' AND b.block_type='finish'\n  ORDER BY CASE WHEN p_pick_strategy='random' THEN random() ELSE b.id::text END\n  LIMIT 1;\n\n  IF v_prep IS NULL OR v_build IS NULL OR v_capacity IS NULL OR v_finish IS NULL THEN\n    RAISE EXCEPTION 'Seed blocks missing. Did you run the seed script (notes=seed:blocks_v1)?';\n  END IF;\n\n  -- upsert selections (one block per type per day)\n  INSERT INTO public.daily_workout_blocks (daily_workout_id, block_type, block_id, variant)\n  VALUES\n    (p_daily_workout_id, 'prep',     v_prep,     p_prep_variant),\n    (p_daily_workout_id, 'build',    v_build,    p_build_variant),\n    (p_daily_workout_id, 'capacity', v_capacity, p_capacity_variant),\n    (p_daily_workout_id, 'finish',   v_finish,   p_finish_variant)\n  ON CONFLICT (daily_workout_id, block_type) DO UPDATE\n  SET block_id = EXCLUDED.block_id,\n      variant  = EXCLUDED.variant;\n\n  -- snapshot movements for the day (idempotent)\n  PERFORM public.materialize_daily_workout_movements(p_daily_workout_id, true);\n\n  -- return what we assigned\n  RETURN QUERY\n  SELECT * FROM (VALUES\n    ('prep',     v_prep,     p_prep_variant),\n    ('build',    v_build,    p_build_variant),\n    ('capacity', v_capacity, p_capacity_variant),\n    ('finish',   v_finish,   p_finish_variant)\n  ) AS t(block_type, block_id, variant);\nEND "
  },
  {
    "schema_name": "public",
    "function_name": "blocks_validate_goal_vector",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.blocks_validate_goal_vector()\n RETURNS trigger\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nDECLARE\n  expected_count int;\n  key_count      int;\n  missing_count  int;\n  extra_count    int;\nBEGIN\n  -- how many goals exist right now?\n  SELECT count(*) INTO expected_count FROM public.goals;\n\n  -- count keys present in the incoming JSON object\n  SELECT count(*) INTO key_count\n  FROM jsonb_object_keys(NEW.goal_impact_vector);\n\n  -- how many goal ids are missing from the JSON?\n  SELECT count(*) INTO missing_count\n  FROM public.goals g\n  WHERE NOT (NEW.goal_impact_vector ? g.id::text);\n\n  -- how many extra (non-goal) keys are present?\n  SELECT count(*) INTO extra_count\n  FROM jsonb_object_keys(NEW.goal_impact_vector) AS k(key)\n  LEFT JOIN public.goals g ON g.id::text = k.key\n  WHERE g.id IS NULL;\n\n  IF COALESCE(jsonb_typeof(NEW.goal_impact_vector), '') <> 'object'\n     OR key_count <> expected_count\n     OR missing_count > 0\n     OR extra_count > 0\n  THEN\n    RAISE EXCEPTION\n      'goal_impact_vector must include exactly the current public.goals ids; expected=%, found_keys=%, missing=%, extra=%',\n      expected_count, key_count, missing_count, extra_count\n      USING HINT = 'Run public.rebuild_block_goal_vectors() after editing public.goals.';\n  END IF;\n\n  RETURN NEW;\nEND $function$\n",
    "source_code": "\nDECLARE\n  expected_count int;\n  key_count      int;\n  missing_count  int;\n  extra_count    int;\nBEGIN\n  -- how many goals exist right now?\n  SELECT count(*) INTO expected_count FROM public.goals;\n\n  -- count keys present in the incoming JSON object\n  SELECT count(*) INTO key_count\n  FROM jsonb_object_keys(NEW.goal_impact_vector);\n\n  -- how many goal ids are missing from the JSON?\n  SELECT count(*) INTO missing_count\n  FROM public.goals g\n  WHERE NOT (NEW.goal_impact_vector ? g.id::text);\n\n  -- how many extra (non-goal) keys are present?\n  SELECT count(*) INTO extra_count\n  FROM jsonb_object_keys(NEW.goal_impact_vector) AS k(key)\n  LEFT JOIN public.goals g ON g.id::text = k.key\n  WHERE g.id IS NULL;\n\n  IF COALESCE(jsonb_typeof(NEW.goal_impact_vector), '') <> 'object'\n     OR key_count <> expected_count\n     OR missing_count > 0\n     OR extra_count > 0\n  THEN\n    RAISE EXCEPTION\n      'goal_impact_vector must include exactly the current public.goals ids; expected=%, found_keys=%, missing=%, extra=%',\n      expected_count, key_count, missing_count, extra_count\n      USING HINT = 'Run public.rebuild_block_goal_vectors() after editing public.goals.';\n  END IF;\n\n  RETURN NEW;\nEND "
  },
  {
    "schema_name": "public",
    "function_name": "compute_default_sport_vector",
    "arguments": "p_pattern_name text, p_pattern_type text, p_movement_name text",
    "return_type": "jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION public.compute_default_sport_vector(p_pattern_name text, p_pattern_type text, p_movement_name text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\ndeclare\n  t   text := lower(coalesce(p_pattern_type,''));\n  pn  text := lower(coalesce(p_pattern_name,''));\n  mn  text := lower(coalesce(p_movement_name,''));\n  v   jsonb;\nbegin\n  if t = 'strength' then\n    v := jsonb_build_object(\n      'Soccer',0.45,'Basketball',0.50,'Football',0.70,'Tennis',0.45,\n      'Short distance running',0.55,'Mid distance running',0.35,'Long distance running',0.30,\n      'Triathlons',0.35,'Crossfit',0.60,'Hyrox',0.60\n    );\n  elsif t = 'endurance' then\n    v := jsonb_build_object(\n      'Soccer',0.60,'Basketball',0.55,'Football',0.40,'Tennis',0.55,\n      'Short distance running',0.65,'Mid distance running',0.75,'Long distance running',0.85,\n      'Triathlons',0.80,'Crossfit',0.60,'Hyrox',0.65\n    );\n  elsif t = 'mobility' then\n    v := jsonb_build_object(\n      'Soccer',0.50,'Basketball',0.50,'Football',0.45,'Tennis',0.50,\n      'Short distance running',0.45,'Mid distance running',0.45,'Long distance running',0.45,\n      'Triathlons',0.45,'Crossfit',0.45,'Hyrox',0.45\n    );\n  elsif t = 'stability' then\n    v := jsonb_build_object(\n      'Soccer',0.55,'Basketball',0.55,'Football',0.60,'Tennis',0.55,\n      'Short distance running',0.45,'Mid distance running',0.40,'Long distance running',0.35,\n      'Triathlons',0.40,'Crossfit',0.65,'Hyrox',0.55\n    );\n  else\n    v := jsonb_build_object(\n      'Soccer',0.50,'Basketball',0.50,'Football',0.50,'Tennis',0.50,\n      'Short distance running',0.50,'Mid distance running',0.50,'Long distance running',0.50,\n      'Triathlons',0.50,'Crossfit',0.50,'Hyrox',0.50\n    );\n  end if;\n\n  -- pattern overrides (same as before)\n  if pn like 'gait / locomotion%' then\n    if mn like 'walk%' then\n      v := v || jsonb_build_object('Short distance running',0.30,'Mid distance running',0.35,'Long distance running',0.40,'Triathlons',0.30);\n    elsif mn like 'jog%' then\n      v := v || jsonb_build_object('Mid distance running',0.70,'Long distance running',0.60,'Triathlons',0.60);\n    elsif mn = 'run' then\n      v := v || jsonb_build_object('Mid distance running',0.75,'Long distance running',0.70,'Triathlons',0.65);\n    elsif mn like 'sprint%' then\n      v := v || jsonb_build_object('Short distance running',0.90,'Soccer',0.70,'Basketball',0.60,'Hyrox',0.60,'Crossfit',0.60);\n    end if;\n  end if;\n\n  if pn like 'carry / load transport%' then\n    v := v || jsonb_build_object('Hyrox',0.90,'Crossfit',0.75,'Football',0.70);\n  end if;\n\n  if pn like 'cyclic lower body%' then\n    v := v || jsonb_build_object('Triathlons',0.70,'Mid distance running',0.70,'Long distance running',0.60);\n  end if;\n\n  if pn like 'mixed modal conditioning%' then\n    v := v || jsonb_build_object('Crossfit',0.90,'Hyrox',0.85,'Soccer',0.60,'Basketball',0.60);\n  end if;\n\n  if pn like 'swimming / aquatic locomotion%' or mn like '%swim%' then\n    v := v || jsonb_build_object('Triathlons',0.85,'Short distance running',0.30,'Mid distance running',0.30,'Long distance running',0.30);\n  end if;\n\n  if mn like '%sled push%' then\n    v := v || jsonb_build_object('Hyrox',0.95,'Crossfit',0.80,'Short distance running',0.70,'Football',0.70);\n  end if;\n  if mn like '%rowing erg%' then\n    v := v || jsonb_build_object('Crossfit',0.70,'Hyrox',0.60,'Triathlons',0.35);\n  end if;\n  if mn like '%burpee%' then\n    v := v || jsonb_build_object('Crossfit',0.85,'Hyrox',0.70);\n  end if;\n  if mn like '%shuttle run with push-up%' then\n    v := v || jsonb_build_object('Short distance running',0.70,'Crossfit',0.75,'Hyrox',0.70);\n  end if;\n  if mn like '%bear crawl%' then\n    v := v || jsonb_build_object('Crossfit',0.70,'Hyrox',0.60);\n  end if;\n\n  return v;\nend $function$\n",
    "source_code": "\ndeclare\n  t   text := lower(coalesce(p_pattern_type,''));\n  pn  text := lower(coalesce(p_pattern_name,''));\n  mn  text := lower(coalesce(p_movement_name,''));\n  v   jsonb;\nbegin\n  if t = 'strength' then\n    v := jsonb_build_object(\n      'Soccer',0.45,'Basketball',0.50,'Football',0.70,'Tennis',0.45,\n      'Short distance running',0.55,'Mid distance running',0.35,'Long distance running',0.30,\n      'Triathlons',0.35,'Crossfit',0.60,'Hyrox',0.60\n    );\n  elsif t = 'endurance' then\n    v := jsonb_build_object(\n      'Soccer',0.60,'Basketball',0.55,'Football',0.40,'Tennis',0.55,\n      'Short distance running',0.65,'Mid distance running',0.75,'Long distance running',0.85,\n      'Triathlons',0.80,'Crossfit',0.60,'Hyrox',0.65\n    );\n  elsif t = 'mobility' then\n    v := jsonb_build_object(\n      'Soccer',0.50,'Basketball',0.50,'Football',0.45,'Tennis',0.50,\n      'Short distance running',0.45,'Mid distance running',0.45,'Long distance running',0.45,\n      'Triathlons',0.45,'Crossfit',0.45,'Hyrox',0.45\n    );\n  elsif t = 'stability' then\n    v := jsonb_build_object(\n      'Soccer',0.55,'Basketball',0.55,'Football',0.60,'Tennis',0.55,\n      'Short distance running',0.45,'Mid distance running',0.40,'Long distance running',0.35,\n      'Triathlons',0.40,'Crossfit',0.65,'Hyrox',0.55\n    );\n  else\n    v := jsonb_build_object(\n      'Soccer',0.50,'Basketball',0.50,'Football',0.50,'Tennis',0.50,\n      'Short distance running',0.50,'Mid distance running',0.50,'Long distance running',0.50,\n      'Triathlons',0.50,'Crossfit',0.50,'Hyrox',0.50\n    );\n  end if;\n\n  -- pattern overrides (same as before)\n  if pn like 'gait / locomotion%' then\n    if mn like 'walk%' then\n      v := v || jsonb_build_object('Short distance running',0.30,'Mid distance running',0.35,'Long distance running',0.40,'Triathlons',0.30);\n    elsif mn like 'jog%' then\n      v := v || jsonb_build_object('Mid distance running',0.70,'Long distance running',0.60,'Triathlons',0.60);\n    elsif mn = 'run' then\n      v := v || jsonb_build_object('Mid distance running',0.75,'Long distance running',0.70,'Triathlons',0.65);\n    elsif mn like 'sprint%' then\n      v := v || jsonb_build_object('Short distance running',0.90,'Soccer',0.70,'Basketball',0.60,'Hyrox',0.60,'Crossfit',0.60);\n    end if;\n  end if;\n\n  if pn like 'carry / load transport%' then\n    v := v || jsonb_build_object('Hyrox',0.90,'Crossfit',0.75,'Football',0.70);\n  end if;\n\n  if pn like 'cyclic lower body%' then\n    v := v || jsonb_build_object('Triathlons',0.70,'Mid distance running',0.70,'Long distance running',0.60);\n  end if;\n\n  if pn like 'mixed modal conditioning%' then\n    v := v || jsonb_build_object('Crossfit',0.90,'Hyrox',0.85,'Soccer',0.60,'Basketball',0.60);\n  end if;\n\n  if pn like 'swimming / aquatic locomotion%' or mn like '%swim%' then\n    v := v || jsonb_build_object('Triathlons',0.85,'Short distance running',0.30,'Mid distance running',0.30,'Long distance running',0.30);\n  end if;\n\n  if mn like '%sled push%' then\n    v := v || jsonb_build_object('Hyrox',0.95,'Crossfit',0.80,'Short distance running',0.70,'Football',0.70);\n  end if;\n  if mn like '%rowing erg%' then\n    v := v || jsonb_build_object('Crossfit',0.70,'Hyrox',0.60,'Triathlons',0.35);\n  end if;\n  if mn like '%burpee%' then\n    v := v || jsonb_build_object('Crossfit',0.85,'Hyrox',0.70);\n  end if;\n  if mn like '%shuttle run with push-up%' then\n    v := v || jsonb_build_object('Short distance running',0.70,'Crossfit',0.75,'Hyrox',0.70);\n  end if;\n  if mn like '%bear crawl%' then\n    v := v || jsonb_build_object('Crossfit',0.70,'Hyrox',0.60);\n  end if;\n\n  return v;\nend "
  },
  {
    "schema_name": "public",
    "function_name": "json_keys_exist_in_modules",
    "arguments": "vec jsonb",
    "return_type": "boolean",
    "function_definition": "CREATE OR REPLACE FUNCTION public.json_keys_exist_in_modules(vec jsonb)\n RETURNS boolean\n LANGUAGE sql\n STABLE\nAS $function$\n  SELECT NOT EXISTS (\n    SELECT 1\n    FROM jsonb_object_keys(vec) k\n    LEFT JOIN public.modules m ON m.id::text = k\n    WHERE m.id IS NULL\n  );\n$function$\n",
    "source_code": "\n  SELECT NOT EXISTS (\n    SELECT 1\n    FROM jsonb_object_keys(vec) k\n    LEFT JOIN public.modules m ON m.id::text = k\n    WHERE m.id IS NULL\n  );\n"
  },
  {
    "schema_name": "public",
    "function_name": "json_score_object_in_range",
    "arguments": "vec jsonb, lo numeric, hi numeric",
    "return_type": "boolean",
    "function_definition": "CREATE OR REPLACE FUNCTION public.json_score_object_in_range(vec jsonb, lo numeric, hi numeric)\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n  SELECT\n    jsonb_typeof(vec) = 'object'\n    AND NOT EXISTS (\n      SELECT 1\n      FROM jsonb_each(vec) e(k, v)\n      WHERE jsonb_typeof(v) NOT IN ('number','integer')\n         OR (v::text)::numeric < lo\n         OR (v::text)::numeric > hi\n    );\n$function$\n",
    "source_code": "\n  SELECT\n    jsonb_typeof(vec) = 'object'\n    AND NOT EXISTS (\n      SELECT 1\n      FROM jsonb_each(vec) e(k, v)\n      WHERE jsonb_typeof(v) NOT IN ('number','integer')\n         OR (v::text)::numeric < lo\n         OR (v::text)::numeric > hi\n    );\n"
  },
  {
    "schema_name": "public",
    "function_name": "materialize_daily_workout_movements",
    "arguments": "p_daily_workout_id bigint, p_reset boolean DEFAULT true",
    "return_type": "integer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.materialize_daily_workout_movements(p_daily_workout_id bigint, p_reset boolean DEFAULT true)\n RETURNS integer\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nDECLARE\n  v_exists boolean;\n  v_rows   integer;\nBEGIN\n  -- 0) Verify the workout exists (FK would catch on insert, but fail early is cleaner)\n  SELECT TRUE INTO v_exists\n  FROM public.daily_workouts\n  WHERE id = p_daily_workout_id;\n  IF NOT v_exists THEN\n    RAISE EXCEPTION 'daily_workouts.id % does not exist', p_daily_workout_id;\n  END IF;\n\n  -- 1) Optionally clear any previous snapshot for this day (idempotent rebuild)\n  IF p_reset THEN\n    DELETE FROM public.daily_workout_movements\n    WHERE daily_workout_id = p_daily_workout_id;\n  END IF;\n\n  -- 2) Ensure there are blocks attached (one per type at most, enforced elsewhere)\n  PERFORM 1\n  FROM public.daily_workout_blocks\n  WHERE daily_workout_id = p_daily_workout_id;\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'No blocks assigned for daily_workout_id %, cannot materialize', p_daily_workout_id;\n  END IF;\n\n  -- 3) Insert snapshot: expand the chosen variant and order items across the day\n  WITH expanded AS (\n    SELECT\n      d.block_type,\n      d.variant,\n      i.sequence          AS item_seq,\n      i.movement_uuid     AS movement_id\n    FROM public.daily_workout_blocks d\n    JOIN public.movement_block_items i\n      ON i.block_id = d.block_id\n     AND (i.variants ? d.variant)\n     AND (i.variants->>d.variant)::boolean = TRUE\n    WHERE d.daily_workout_id = p_daily_workout_id\n  ),\n  ordered AS (\n    SELECT\n      ROW_NUMBER() OVER (\n        ORDER BY\n          CASE block_type\n            WHEN 'prep' THEN 1\n            WHEN 'build' THEN 2\n            WHEN 'capacity' THEN 3\n            WHEN 'finish' THEN 4\n          END,\n          item_seq\n      ) AS seq,\n      movement_id\n    FROM expanded\n  )\n  INSERT INTO public.daily_workout_movements (\n    daily_workout_id,\n    sequence,\n    status,\n    assigned_intensity,\n    recovery_impact_score,\n    resilience_impact_score,\n    results_impact_score,\n    movement_id,\n    source_movement_id\n  )\n  SELECT\n    p_daily_workout_id,\n    o.seq,\n    'pending',        -- default starting state\n    NULL, NULL, NULL, NULL,\n    o.movement_id,    -- assigned\n    o.movement_id     -- provenance (template); change this ONLY if you want to point at a different template\n  FROM ordered o\n  RETURNING 1\n  INTO v_rows;\n\n  GET DIAGNOSTICS v_rows = ROW_COUNT;\n  IF v_rows = 0 THEN\n    RAISE EXCEPTION 'No block items matched the chosen variants for daily_workout_id %', p_daily_workout_id;\n  END IF;\n\n  RETURN v_rows;\nEND $function$\n",
    "source_code": "\nDECLARE\n  v_exists boolean;\n  v_rows   integer;\nBEGIN\n  -- 0) Verify the workout exists (FK would catch on insert, but fail early is cleaner)\n  SELECT TRUE INTO v_exists\n  FROM public.daily_workouts\n  WHERE id = p_daily_workout_id;\n  IF NOT v_exists THEN\n    RAISE EXCEPTION 'daily_workouts.id % does not exist', p_daily_workout_id;\n  END IF;\n\n  -- 1) Optionally clear any previous snapshot for this day (idempotent rebuild)\n  IF p_reset THEN\n    DELETE FROM public.daily_workout_movements\n    WHERE daily_workout_id = p_daily_workout_id;\n  END IF;\n\n  -- 2) Ensure there are blocks attached (one per type at most, enforced elsewhere)\n  PERFORM 1\n  FROM public.daily_workout_blocks\n  WHERE daily_workout_id = p_daily_workout_id;\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'No blocks assigned for daily_workout_id %, cannot materialize', p_daily_workout_id;\n  END IF;\n\n  -- 3) Insert snapshot: expand the chosen variant and order items across the day\n  WITH expanded AS (\n    SELECT\n      d.block_type,\n      d.variant,\n      i.sequence          AS item_seq,\n      i.movement_uuid     AS movement_id\n    FROM public.daily_workout_blocks d\n    JOIN public.movement_block_items i\n      ON i.block_id = d.block_id\n     AND (i.variants ? d.variant)\n     AND (i.variants->>d.variant)::boolean = TRUE\n    WHERE d.daily_workout_id = p_daily_workout_id\n  ),\n  ordered AS (\n    SELECT\n      ROW_NUMBER() OVER (\n        ORDER BY\n          CASE block_type\n            WHEN 'prep' THEN 1\n            WHEN 'build' THEN 2\n            WHEN 'capacity' THEN 3\n            WHEN 'finish' THEN 4\n          END,\n          item_seq\n      ) AS seq,\n      movement_id\n    FROM expanded\n  )\n  INSERT INTO public.daily_workout_movements (\n    daily_workout_id,\n    sequence,\n    status,\n    assigned_intensity,\n    recovery_impact_score,\n    resilience_impact_score,\n    results_impact_score,\n    movement_id,\n    source_movement_id\n  )\n  SELECT\n    p_daily_workout_id,\n    o.seq,\n    'pending',        -- default starting state\n    NULL, NULL, NULL, NULL,\n    o.movement_id,    -- assigned\n    o.movement_id     -- provenance (template); change this ONLY if you want to point at a different template\n  FROM ordered o\n  RETURNING 1\n  INTO v_rows;\n\n  GET DIAGNOSTICS v_rows = ROW_COUNT;\n  IF v_rows = 0 THEN\n    RAISE EXCEPTION 'No block items matched the chosen variants for daily_workout_id %', p_daily_workout_id;\n  END IF;\n\n  RETURN v_rows;\nEND "
  },
  {
    "schema_name": "public",
    "function_name": "movements_normalize_and_validate_dose_ids",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.movements_normalize_and_validate_dose_ids()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  invalid_cnt integer;\n  normalized uuid[];\nBEGIN\n  IF NEW.allowed_dose_metric_ids IS NULL THEN\n    NEW.allowed_dose_metric_ids := '{}'::uuid[];\n  END IF;\n\n  -- dedupe + sort for stability\n  SELECT COALESCE(array_agg(u ORDER BY u), '{}') INTO normalized\n  FROM (SELECT DISTINCT unnest(NEW.allowed_dose_metric_ids) AS u) s;\n  NEW.allowed_dose_metric_ids := normalized;\n\n  -- ensure every id exists in public.dose_metrics\n  SELECT COUNT(*) INTO invalid_cnt\n  FROM unnest(NEW.allowed_dose_metric_ids) AS d(id)\n  LEFT JOIN public.dose_metrics m ON m.id = d.id\n  WHERE m.id IS NULL;\n\n  IF invalid_cnt > 0 THEN\n    RAISE EXCEPTION 'allowed_dose_metric_ids contains IDs not found in public.dose_metrics';\n  END IF;\n\n  RETURN NEW;\nEND;\n$function$\n",
    "source_code": "\nDECLARE\n  invalid_cnt integer;\n  normalized uuid[];\nBEGIN\n  IF NEW.allowed_dose_metric_ids IS NULL THEN\n    NEW.allowed_dose_metric_ids := '{}'::uuid[];\n  END IF;\n\n  -- dedupe + sort for stability\n  SELECT COALESCE(array_agg(u ORDER BY u), '{}') INTO normalized\n  FROM (SELECT DISTINCT unnest(NEW.allowed_dose_metric_ids) AS u) s;\n  NEW.allowed_dose_metric_ids := normalized;\n\n  -- ensure every id exists in public.dose_metrics\n  SELECT COUNT(*) INTO invalid_cnt\n  FROM unnest(NEW.allowed_dose_metric_ids) AS d(id)\n  LEFT JOIN public.dose_metrics m ON m.id = d.id\n  WHERE m.id IS NULL;\n\n  IF invalid_cnt > 0 THEN\n    RAISE EXCEPTION 'allowed_dose_metric_ids contains IDs not found in public.dose_metrics';\n  END IF;\n\n  RETURN NEW;\nEND;\n"
  },
  {
    "schema_name": "public",
    "function_name": "movements_required_equipment_guard",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.movements_required_equipment_guard()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n    DECLARE\n      missing_ct int;\n    BEGIN\n      NEW.required_equipment := public.normalize_int4_array(NEW.required_equipment);\n\n      SELECT COUNT(*)\n      INTO missing_ct\n      FROM (\n        SELECT x.eid\n        FROM unnest(COALESCE(NEW.required_equipment, '{}'::int4[])) AS x(eid)\n        LEFT JOIN public.equipment eq ON eq.id = x.eid\n        WHERE eq.id IS NULL\n      ) AS m;\n\n      IF missing_ct > 0 THEN\n        RAISE EXCEPTION 'required_equipment contains unknown equipment id(s)';\n      END IF;\n\n      RETURN NEW;\n    END;\n    $function$\n",
    "source_code": "\n    DECLARE\n      missing_ct int;\n    BEGIN\n      NEW.required_equipment := public.normalize_int4_array(NEW.required_equipment);\n\n      SELECT COUNT(*)\n      INTO missing_ct\n      FROM (\n        SELECT x.eid\n        FROM unnest(COALESCE(NEW.required_equipment, '{}'::int4[])) AS x(eid)\n        LEFT JOIN public.equipment eq ON eq.id = x.eid\n        WHERE eq.id IS NULL\n      ) AS m;\n\n      IF missing_ct > 0 THEN\n        RAISE EXCEPTION 'required_equipment contains unknown equipment id(s)';\n      END IF;\n\n      RETURN NEW;\n    END;\n    "
  },
  {
    "schema_name": "public",
    "function_name": "movements_sanitize_injury_flags",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.movements_sanitize_injury_flags()\n RETURNS trigger\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nDECLARE\n  badshape boolean;\n  cleaned_ind jsonb := '[]'::jsonb;\n  cleaned_con jsonb := '[]'::jsonb;\nBEGIN\n  -- Coerce nulls to the canonical empty object\n  IF NEW.default_injury_flags IS NULL THEN\n    NEW.default_injury_flags := jsonb_build_object('indication','[]'::jsonb,'contraindication','[]'::jsonb);\n  END IF;\n\n  -- Basic shape\n  badshape := NOT (\n    jsonb_typeof(NEW.default_injury_flags) = 'object'\n    AND NEW.default_injury_flags ? 'indication'\n    AND NEW.default_injury_flags ? 'contraindication'\n    AND jsonb_typeof(NEW.default_injury_flags->'indication') = 'array'\n    AND jsonb_typeof(NEW.default_injury_flags->'contraindication') = 'array'\n  );\n  IF badshape THEN\n    RAISE EXCEPTION 'default_injury_flags must be {\"indication\":[...], \"contraindication\":[...]} with arrays of ids';\n  END IF;\n\n  -- De-dup, drop non-numeric, enforce FK membership\n  WITH\n  ind AS (\n    SELECT DISTINCT v::int AS id\n    FROM jsonb_array_elements_text(NEW.default_injury_flags->'indication') e(v)\n    WHERE v ~ '^\\d+$'\n  ),\n  con AS (\n    SELECT DISTINCT v::int AS id\n    FROM jsonb_array_elements_text(NEW.default_injury_flags->'contraindication') e(v)\n    WHERE v ~ '^\\d+$'\n  ),\n  valid_ind AS (\n    SELECT i.id\n    FROM ind i JOIN public.injuries inj ON inj.id = i.id\n    EXCEPT SELECT id FROM con          -- contraindication wins\n  ),\n  valid_con AS (\n    SELECT c.id\n    FROM con c JOIN public.injuries inj ON inj.id = c.id\n  )\n  SELECT\n    COALESCE(jsonb_agg(id) FILTER (WHERE TRUE), '[]'::jsonb),\n    COALESCE(jsonb_agg(id) FILTER (WHERE TRUE), '[]'::jsonb)\n  INTO cleaned_ind, cleaned_con\n  FROM valid_ind\n  FULL JOIN valid_con USING (id);\n\n  NEW.default_injury_flags := jsonb_build_object('indication', cleaned_ind, 'contraindication', cleaned_con);\n  RETURN NEW;\nEND $function$\n",
    "source_code": "\nDECLARE\n  badshape boolean;\n  cleaned_ind jsonb := '[]'::jsonb;\n  cleaned_con jsonb := '[]'::jsonb;\nBEGIN\n  -- Coerce nulls to the canonical empty object\n  IF NEW.default_injury_flags IS NULL THEN\n    NEW.default_injury_flags := jsonb_build_object('indication','[]'::jsonb,'contraindication','[]'::jsonb);\n  END IF;\n\n  -- Basic shape\n  badshape := NOT (\n    jsonb_typeof(NEW.default_injury_flags) = 'object'\n    AND NEW.default_injury_flags ? 'indication'\n    AND NEW.default_injury_flags ? 'contraindication'\n    AND jsonb_typeof(NEW.default_injury_flags->'indication') = 'array'\n    AND jsonb_typeof(NEW.default_injury_flags->'contraindication') = 'array'\n  );\n  IF badshape THEN\n    RAISE EXCEPTION 'default_injury_flags must be {\"indication\":[...], \"contraindication\":[...]} with arrays of ids';\n  END IF;\n\n  -- De-dup, drop non-numeric, enforce FK membership\n  WITH\n  ind AS (\n    SELECT DISTINCT v::int AS id\n    FROM jsonb_array_elements_text(NEW.default_injury_flags->'indication') e(v)\n    WHERE v ~ '^\\d+$'\n  ),\n  con AS (\n    SELECT DISTINCT v::int AS id\n    FROM jsonb_array_elements_text(NEW.default_injury_flags->'contraindication') e(v)\n    WHERE v ~ '^\\d+$'\n  ),\n  valid_ind AS (\n    SELECT i.id\n    FROM ind i JOIN public.injuries inj ON inj.id = i.id\n    EXCEPT SELECT id FROM con          -- contraindication wins\n  ),\n  valid_con AS (\n    SELECT c.id\n    FROM con c JOIN public.injuries inj ON inj.id = c.id\n  )\n  SELECT\n    COALESCE(jsonb_agg(id) FILTER (WHERE TRUE), '[]'::jsonb),\n    COALESCE(jsonb_agg(id) FILTER (WHERE TRUE), '[]'::jsonb)\n  INTO cleaned_ind, cleaned_con\n  FROM valid_ind\n  FULL JOIN valid_con USING (id);\n\n  NEW.default_injury_flags := jsonb_build_object('indication', cleaned_ind, 'contraindication', cleaned_con);\n  RETURN NEW;\nEND "
  },
  {
    "schema_name": "public",
    "function_name": "movements_validate_super_metric_vector",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.movements_validate_super_metric_vector()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN NEW;\nEND;\n$function$\n",
    "source_code": "\nBEGIN\n  RETURN NEW;\nEND;\n"
  },
  {
    "schema_name": "public",
    "function_name": "normalize_int4_array",
    "arguments": "arr integer[]",
    "return_type": "integer[]",
    "function_definition": "CREATE OR REPLACE FUNCTION public.normalize_int4_array(arr integer[])\n RETURNS integer[]\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n      SELECT CASE\n               WHEN arr IS NULL THEN '{}'::int4[]\n               ELSE ARRAY(\n                 SELECT DISTINCT e\n                 FROM unnest(arr) AS e\n                 WHERE e IS NOT NULL\n                 ORDER BY 1\n               )\n             END\n    $function$\n",
    "source_code": "\n      SELECT CASE\n               WHEN arr IS NULL THEN '{}'::int4[]\n               ELSE ARRAY(\n                 SELECT DISTINCT e\n                 FROM unnest(arr) AS e\n                 WHERE e IS NOT NULL\n                 ORDER BY 1\n               )\n             END\n    "
  },
  {
    "schema_name": "public",
    "function_name": "progress_dose",
    "arguments": "p_week_index smallint, p_block_type_label text, p_base jsonb",
    "return_type": "jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION public.progress_dose(p_week_index smallint, p_block_type_label text, p_base jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_phase       int;\n  v_label       text := lower(coalesce(p_block_type_label,''));\n  v_time_id     uuid;\n  v_reps_id     uuid;\n  v_out         jsonb := coalesce(p_base, '{}'::jsonb);\n  v_base_secs   numeric;\n  v_new_secs    int;\n  v_new_reps    int;\n  v_mult        numeric := 1.0;\nbegin\n  -- Phase from week_index: 1..4 → 1, 5..8 → 2, 9..12 → 3 (clamp outside range)\n  if p_week_index between 1 and 4 then\n    v_phase := 1;\n  elsif p_week_index between 5 and 8 then\n    v_phase := 2;\n  else\n    v_phase := 3;\n  end if;\n\n  -- Look up metric UUIDs by KEY (stable across display_name edits)\n  select id into v_time_id from public.dose_metrics where key = 'time_s'  limit 1;\n  select id into v_reps_id from public.dose_metrics where key = 'reps'    limit 1;\n\n  -- Warm-up / Cooldown: return unchanged\n  if v_label in ('warm-up','warm up','warmup','cooldown','cool down','cool-down') then\n    return v_out;\n  end if;\n\n  -- Aerobic: scale time_s per phase (1.00, 1.125, 1.25)\n  if v_label = 'aerobic' then\n    if v_time_id is not null and v_out ? (v_time_id::text) then\n      if v_phase = 1 then v_mult := 1.00;\n      elsif v_phase = 2 then v_mult := 1.125;\n      else v_mult := 1.25;\n      end if;\n\n      v_base_secs := nullif((v_out ->> (v_time_id::text)), '')::numeric;\n      if v_base_secs is not null then\n        v_new_secs := round(v_base_secs * v_mult)::int;\n        v_out := jsonb_set(v_out, ARRAY[v_time_id::text], to_jsonb(v_new_secs), true);\n      end if;\n    end if;\n\n    return v_out;\n  end if;\n\n  -- Strength & Conditioning: adjust reps per phase (10, 8, 6)\n  if v_label in ('strength & conditioning','strength and conditioning') then\n    if v_reps_id is not null and v_out ? (v_reps_id::text) then\n      if v_phase = 1 then v_new_reps := 10;\n      elsif v_phase = 2 then v_new_reps := 8;\n      else v_new_reps := 6;\n      end if;\n\n      v_out := jsonb_set(v_out, ARRAY[v_reps_id::text], to_jsonb(v_new_reps), true);\n    end if;\n\n    return v_out;\n  end if;\n\n  -- Any other block types (unlikely): unchanged\n  return v_out;\nend;\n$function$\n",
    "source_code": "\ndeclare\n  v_phase       int;\n  v_label       text := lower(coalesce(p_block_type_label,''));\n  v_time_id     uuid;\n  v_reps_id     uuid;\n  v_out         jsonb := coalesce(p_base, '{}'::jsonb);\n  v_base_secs   numeric;\n  v_new_secs    int;\n  v_new_reps    int;\n  v_mult        numeric := 1.0;\nbegin\n  -- Phase from week_index: 1..4 → 1, 5..8 → 2, 9..12 → 3 (clamp outside range)\n  if p_week_index between 1 and 4 then\n    v_phase := 1;\n  elsif p_week_index between 5 and 8 then\n    v_phase := 2;\n  else\n    v_phase := 3;\n  end if;\n\n  -- Look up metric UUIDs by KEY (stable across display_name edits)\n  select id into v_time_id from public.dose_metrics where key = 'time_s'  limit 1;\n  select id into v_reps_id from public.dose_metrics where key = 'reps'    limit 1;\n\n  -- Warm-up / Cooldown: return unchanged\n  if v_label in ('warm-up','warm up','warmup','cooldown','cool down','cool-down') then\n    return v_out;\n  end if;\n\n  -- Aerobic: scale time_s per phase (1.00, 1.125, 1.25)\n  if v_label = 'aerobic' then\n    if v_time_id is not null and v_out ? (v_time_id::text) then\n      if v_phase = 1 then v_mult := 1.00;\n      elsif v_phase = 2 then v_mult := 1.125;\n      else v_mult := 1.25;\n      end if;\n\n      v_base_secs := nullif((v_out ->> (v_time_id::text)), '')::numeric;\n      if v_base_secs is not null then\n        v_new_secs := round(v_base_secs * v_mult)::int;\n        v_out := jsonb_set(v_out, ARRAY[v_time_id::text], to_jsonb(v_new_secs), true);\n      end if;\n    end if;\n\n    return v_out;\n  end if;\n\n  -- Strength & Conditioning: adjust reps per phase (10, 8, 6)\n  if v_label in ('strength & conditioning','strength and conditioning') then\n    if v_reps_id is not null and v_out ? (v_reps_id::text) then\n      if v_phase = 1 then v_new_reps := 10;\n      elsif v_phase = 2 then v_new_reps := 8;\n      else v_new_reps := 6;\n      end if;\n\n      v_out := jsonb_set(v_out, ARRAY[v_reps_id::text], to_jsonb(v_new_reps), true);\n    end if;\n\n    return v_out;\n  end if;\n\n  -- Any other block types (unlikely): unchanged\n  return v_out;\nend;\n"
  },
  {
    "schema_name": "public",
    "function_name": "rebuild_block_goal_vectors",
    "arguments": "",
    "return_type": "void",
    "function_definition": "CREATE OR REPLACE FUNCTION public.rebuild_block_goal_vectors()\n RETURNS void\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\n  UPDATE public.movement_blocks b\n  SET goal_impact_vector = (\n    SELECT jsonb_object_agg(\n             g.id::text,\n             to_jsonb(COALESCE( (b.goal_impact_vector->>g.id::text)::int, 0 ))\n           )\n    FROM public.goals g\n  );\n$function$\n",
    "source_code": "\n  UPDATE public.movement_blocks b\n  SET goal_impact_vector = (\n    SELECT jsonb_object_agg(\n             g.id::text,\n             to_jsonb(COALESCE( (b.goal_impact_vector->>g.id::text)::int, 0 ))\n           )\n    FROM public.goals g\n  );\n"
  },
  {
    "schema_name": "public",
    "function_name": "refresh_movement_library",
    "arguments": "",
    "return_type": "void",
    "function_definition": "CREATE OR REPLACE FUNCTION public.refresh_movement_library()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nBEGIN\n  REFRESH MATERIALIZED VIEW public.movement_library;\nEND$function$\n",
    "source_code": "\nBEGIN\n  REFRESH MATERIALIZED VIEW public.movement_library;\nEND"
  },
  {
    "schema_name": "public",
    "function_name": "set_movement_dose_metrics_by_keys",
    "arguments": "movement_name text, metric_keys text[]",
    "return_type": "void",
    "function_definition": "CREATE OR REPLACE FUNCTION public.set_movement_dose_metrics_by_keys(movement_name text, metric_keys text[])\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  ids uuid[];\nBEGIN\n  SELECT COALESCE(array_agg(m.id ORDER BY m.key), '{}')\n  INTO ids\n  FROM public.dose_metrics m\n  WHERE m.key = ANY(metric_keys);\n\n  IF array_length(ids,1) IS NULL THEN\n    RAISE EXCEPTION 'No matching dose_metrics for keys: %', metric_keys;\n  END IF;\n\n  UPDATE public.movements\n  SET allowed_dose_metric_ids = ids\n  WHERE name = movement_name;\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Movement \"%\" not found', movement_name;\n  END IF;\nEND;\n$function$\n",
    "source_code": "\nDECLARE\n  ids uuid[];\nBEGIN\n  SELECT COALESCE(array_agg(m.id ORDER BY m.key), '{}')\n  INTO ids\n  FROM public.dose_metrics m\n  WHERE m.key = ANY(metric_keys);\n\n  IF array_length(ids,1) IS NULL THEN\n    RAISE EXCEPTION 'No matching dose_metrics for keys: %', metric_keys;\n  END IF;\n\n  UPDATE public.movements\n  SET allowed_dose_metric_ids = ids\n  WHERE name = movement_name;\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Movement \"%\" not found', movement_name;\n  END IF;\nEND;\n"
  },
  {
    "schema_name": "public",
    "function_name": "set_updated_at",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.set_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n  new.updated_at := now();\n  return new;\nend;\n$function$\n",
    "source_code": "\nbegin\n  new.updated_at := now();\n  return new;\nend;\n"
  },
  {
    "schema_name": "public",
    "function_name": "sync_movements_from_library",
    "arguments": "",
    "return_type": "void",
    "function_definition": "CREATE OR REPLACE FUNCTION public.sync_movements_from_library()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nBEGIN\n  -- Upsert into public.movements from the materialized view\n  INSERT INTO public.movements AS m (id, name, description, video_url, joints_impacted, muscles_impacted, super_metrics_impacted)\n  SELECT id, name, description, video_url, joints_impacted, muscles_impacted, super_metrics_impacted\n  FROM public.movement_library\n  ON CONFLICT (id) DO UPDATE SET\n    name = EXCLUDED.name,\n    description = EXCLUDED.description,\n    video_url = EXCLUDED.video_url,\n    joints_impacted = EXCLUDED.joints_impacted,\n    muscles_impacted = EXCLUDED.muscles_impacted,\n    super_metrics_impacted = EXCLUDED.super_metrics_impacted;\nEND$function$\n",
    "source_code": "\nBEGIN\n  -- Upsert into public.movements from the materialized view\n  INSERT INTO public.movements AS m (id, name, description, video_url, joints_impacted, muscles_impacted, super_metrics_impacted)\n  SELECT id, name, description, video_url, joints_impacted, muscles_impacted, super_metrics_impacted\n  FROM public.movement_library\n  ON CONFLICT (id) DO UPDATE SET\n    name = EXCLUDED.name,\n    description = EXCLUDED.description,\n    video_url = EXCLUDED.video_url,\n    joints_impacted = EXCLUDED.joints_impacted,\n    muscles_impacted = EXCLUDED.muscles_impacted,\n    super_metrics_impacted = EXCLUDED.super_metrics_impacted;\nEND"
  },
  {
    "schema_name": "public",
    "function_name": "tg_set_timestamp",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.tg_set_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  NEW.updated_at = now();\n  RETURN NEW;\nEND;\n$function$\n",
    "source_code": "\nBEGIN\n  NEW.updated_at = now();\n  RETURN NEW;\nEND;\n"
  },
  {
    "schema_name": "public",
    "function_name": "tg_touch_block_updated_at",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.tg_touch_block_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  v_block_id uuid;\nBEGIN\n  v_block_id := COALESCE(NEW.block_id, OLD.block_id);\n  UPDATE public.movement_blocks\n     SET updated_at = now()\n   WHERE id = v_block_id;\n  RETURN NULL; -- statement-level effect; row image not needed\nEND;\n$function$\n",
    "source_code": "\nDECLARE\n  v_block_id uuid;\nBEGIN\n  v_block_id := COALESCE(NEW.block_id, OLD.block_id);\n  UPDATE public.movement_blocks\n     SET updated_at = now()\n   WHERE id = v_block_id;\n  RETURN NULL; -- statement-level effect; row image not needed\nEND;\n"
  },
  {
    "schema_name": "public",
    "function_name": "trg_validate_program_workout_at_commit",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.trg_validate_program_workout_at_commit()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n  perform public.validate_single_program_workout(NEW.id);\n  return NEW;\nend;\n$function$\n",
    "source_code": "\nbegin\n  perform public.validate_single_program_workout(NEW.id);\n  return NEW;\nend;\n"
  },
  {
    "schema_name": "public",
    "function_name": "trg_validate_program_workout_blocks",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.trg_validate_program_workout_blocks()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\ndeclare\n  v_program_workout_id uuid;\nbegin\n  v_program_workout_id := coalesce(NEW.program_workout_id, OLD.program_workout_id);\n  perform public.validate_single_program_workout(v_program_workout_id);\n  return null;\nend;\n$function$\n",
    "source_code": "\ndeclare\n  v_program_workout_id uuid;\nbegin\n  v_program_workout_id := coalesce(NEW.program_workout_id, OLD.program_workout_id);\n  perform public.validate_single_program_workout(v_program_workout_id);\n  return null;\nend;\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_updated_at_column",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$function$\n",
    "source_code": "\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_user_workout_status",
    "arguments": "p_user_workout_id uuid, p_status text, p_rpe_session numeric DEFAULT NULL::numeric, p_duration_min integer DEFAULT NULL::integer, p_user_notes text DEFAULT NULL::text",
    "return_type": "TABLE(id uuid, status text, rpe_session numeric, duration_minutes_actual integer, user_notes text, updated_at timestamp with time zone)",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_user_workout_status(p_user_workout_id uuid, p_status text, p_rpe_session numeric DEFAULT NULL::numeric, p_duration_min integer DEFAULT NULL::integer, p_user_notes text DEFAULT NULL::text)\n RETURNS TABLE(id uuid, status text, rpe_session numeric, duration_minutes_actual integer, user_notes text, updated_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_role       text := current_setting('request.jwt.claim.role', true);\n  v_uid        uuid := nullif(current_setting('request.jwt.claim.sub', true), '')::uuid;\n  v_old_status text;\n  v_new_status text := lower(p_status);\nbegin\n  -- require authenticated (or service_role)\n  if coalesce(v_role,'') <> 'service_role' and v_uid is null then\n    raise exception 'unauthorized' using errcode = '42501';\n  end if;\n\n  -- validate status (lowercase only)\n  if v_new_status not in ('started','completed','skipped','cancelled') then\n    raise exception 'invalid status: %', p_status using errcode = '22023';\n  end if;\n\n  -- ownership + lock row\n  select uw.status\n    into v_old_status\n  from public.user_workouts uw\n  join public.user_programs up on up.id = uw.user_program_id\n  where uw.id = p_user_workout_id\n    and (coalesce(v_role,'') = 'service_role' or up.user_id = v_uid)\n  for update;\n\n  if not found then\n    raise exception 'workout % not found or not owned by caller', p_user_workout_id using errcode = '42501';\n  end if;\n\n  -- basic transition guard\n  if v_old_status in ('completed','cancelled') then\n    raise exception 'cannot change status from %', v_old_status using errcode = '23514';\n  end if;\n\n  update public.user_workouts uw\n  set status                  = v_new_status,          -- << lowercase\n      rpe_session             = coalesce(p_rpe_session, uw.rpe_session),\n      duration_minutes_actual = coalesce(p_duration_min, uw.duration_minutes_actual),\n      user_notes              = coalesce(p_user_notes, uw.user_notes),\n      updated_at              = now()\n  where uw.id = p_user_workout_id\n  returning uw.id, uw.status, uw.rpe_session, uw.duration_minutes_actual, uw.user_notes, uw.updated_at\n  into id, status, rpe_session, duration_minutes_actual, user_notes, updated_at;\n\n  return next;\nend;\n$function$\n",
    "source_code": "\ndeclare\n  v_role       text := current_setting('request.jwt.claim.role', true);\n  v_uid        uuid := nullif(current_setting('request.jwt.claim.sub', true), '')::uuid;\n  v_old_status text;\n  v_new_status text := lower(p_status);\nbegin\n  -- require authenticated (or service_role)\n  if coalesce(v_role,'') <> 'service_role' and v_uid is null then\n    raise exception 'unauthorized' using errcode = '42501';\n  end if;\n\n  -- validate status (lowercase only)\n  if v_new_status not in ('started','completed','skipped','cancelled') then\n    raise exception 'invalid status: %', p_status using errcode = '22023';\n  end if;\n\n  -- ownership + lock row\n  select uw.status\n    into v_old_status\n  from public.user_workouts uw\n  join public.user_programs up on up.id = uw.user_program_id\n  where uw.id = p_user_workout_id\n    and (coalesce(v_role,'') = 'service_role' or up.user_id = v_uid)\n  for update;\n\n  if not found then\n    raise exception 'workout % not found or not owned by caller', p_user_workout_id using errcode = '42501';\n  end if;\n\n  -- basic transition guard\n  if v_old_status in ('completed','cancelled') then\n    raise exception 'cannot change status from %', v_old_status using errcode = '23514';\n  end if;\n\n  update public.user_workouts uw\n  set status                  = v_new_status,          -- << lowercase\n      rpe_session             = coalesce(p_rpe_session, uw.rpe_session),\n      duration_minutes_actual = coalesce(p_duration_min, uw.duration_minutes_actual),\n      user_notes              = coalesce(p_user_notes, uw.user_notes),\n      updated_at              = now()\n  where uw.id = p_user_workout_id\n  returning uw.id, uw.status, uw.rpe_session, uw.duration_minutes_actual, uw.user_notes, uw.updated_at\n  into id, status, rpe_session, duration_minutes_actual, user_notes, updated_at;\n\n  return next;\nend;\n"
  },
  {
    "schema_name": "public",
    "function_name": "validate_single_program_workout",
    "arguments": "p_program_workout_id uuid",
    "return_type": "void",
    "function_definition": "CREATE OR REPLACE FUNCTION public.validate_single_program_workout(p_program_workout_id uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\ndeclare\n  v_total_blocks int;\n  v_distinct_buckets int;\n  v_unknown int;\nbegin\n  -- must have exactly 4 blocks\n  select count(*)\n    into v_total_blocks\n  from public.program_workout_blocks pwb\n  where pwb.program_workout_id = p_program_workout_id;\n\n  if v_total_blocks <> 4 then\n    raise exception\n      'program_workout % must have exactly 4 blocks (found %).',\n      p_program_workout_id, v_total_blocks\n      using errcode = '23514';\n  end if;\n\n  -- map block_types.label → canonical buckets\n  with buckets as (\n    select\n      case\n        when lower(bt.label) in ('warm-up','warm up','warmup') then 'warmup'\n        when lower(bt.label) in ('strength & conditioning','strength and conditioning') then 'sc'\n        when lower(bt.label) = 'aerobic' then 'aerobic'\n        when lower(bt.label) in ('cooldown','cool down','cool-down') then 'cooldown'\n        else null\n      end as bucket\n    from public.program_workout_blocks pwb\n    join public.movement_blocks mb on mb.id = pwb.movement_block_id\n    join public.block_types bt      on bt.id = mb.block_type_id\n    where pwb.program_workout_id = p_program_workout_id\n  )\n  select\n    count(distinct bucket),\n    count(*) filter (where bucket is null)\n  into v_distinct_buckets, v_unknown\n  from buckets;\n\n  if v_unknown > 0 then\n    raise exception\n      'program_workout % contains % block(s) with unknown block_types.label.',\n      p_program_workout_id, v_unknown\n      using errcode = '23514';\n  end if;\n\n  if v_distinct_buckets <> 4 then\n    raise exception\n      'program_workout % must include exactly one of each: warmup, sc, aerobic, cooldown (found % distinct).',\n      p_program_workout_id, v_distinct_buckets\n      using errcode = '23514';\n  end if;\nend;\n$function$\n",
    "source_code": "\ndeclare\n  v_total_blocks int;\n  v_distinct_buckets int;\n  v_unknown int;\nbegin\n  -- must have exactly 4 blocks\n  select count(*)\n    into v_total_blocks\n  from public.program_workout_blocks pwb\n  where pwb.program_workout_id = p_program_workout_id;\n\n  if v_total_blocks <> 4 then\n    raise exception\n      'program_workout % must have exactly 4 blocks (found %).',\n      p_program_workout_id, v_total_blocks\n      using errcode = '23514';\n  end if;\n\n  -- map block_types.label → canonical buckets\n  with buckets as (\n    select\n      case\n        when lower(bt.label) in ('warm-up','warm up','warmup') then 'warmup'\n        when lower(bt.label) in ('strength & conditioning','strength and conditioning') then 'sc'\n        when lower(bt.label) = 'aerobic' then 'aerobic'\n        when lower(bt.label) in ('cooldown','cool down','cool-down') then 'cooldown'\n        else null\n      end as bucket\n    from public.program_workout_blocks pwb\n    join public.movement_blocks mb on mb.id = pwb.movement_block_id\n    join public.block_types bt      on bt.id = mb.block_type_id\n    where pwb.program_workout_id = p_program_workout_id\n  )\n  select\n    count(distinct bucket),\n    count(*) filter (where bucket is null)\n  into v_distinct_buckets, v_unknown\n  from buckets;\n\n  if v_unknown > 0 then\n    raise exception\n      'program_workout % contains % block(s) with unknown block_types.label.',\n      p_program_workout_id, v_unknown\n      using errcode = '23514';\n  end if;\n\n  if v_distinct_buckets <> 4 then\n    raise exception\n      'program_workout % must include exactly one of each: warmup, sc, aerobic, cooldown (found % distinct).',\n      p_program_workout_id, v_distinct_buckets\n      using errcode = '23514';\n  end if;\nend;\n"
  }
]