[
  {
    "schema_name": "public",
    "function_name": "_ensure_policy",
    "arguments": "in_schema text, in_table text, in_name text, in_cmd text, in_roles text, in_using text, in_check text",
    "return_type": "void",
    "function_definition": "CREATE OR REPLACE FUNCTION public._ensure_policy(in_schema text, in_table text, in_name text, in_cmd text, in_roles text, in_using text, in_check text)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_policies\n    WHERE schemaname=in_schema AND tablename=in_table AND policyname=in_name\n  ) THEN\n    EXECUTE format(\n      'CREATE POLICY %I ON %I.%I FOR %s TO %s %s %s;',\n      in_name, in_schema, in_table, in_cmd, in_roles,\n      CASE WHEN in_using IS NOT NULL THEN 'USING ('||in_using||')' ELSE '' END,\n      CASE WHEN in_check IS NOT NULL THEN 'WITH CHECK ('||in_check||')' ELSE '' END\n    );\n  END IF;\nEND\n$function$\n",
    "source_code": "\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_policies\n    WHERE schemaname=in_schema AND tablename=in_table AND policyname=in_name\n  ) THEN\n    EXECUTE format(\n      'CREATE POLICY %I ON %I.%I FOR %s TO %s %s %s;',\n      in_name, in_schema, in_table, in_cmd, in_roles,\n      CASE WHEN in_using IS NOT NULL THEN 'USING ('||in_using||')' ELSE '' END,\n      CASE WHEN in_check IS NOT NULL THEN 'WITH CHECK ('||in_check||')' ELSE '' END\n    );\n  END IF;\nEND\n"
  },
  {
    "schema_name": "public",
    "function_name": "_touch_updated_at",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public._touch_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nBEGIN NEW.updated_at = now(); RETURN NEW; END $function$\n",
    "source_code": "\nBEGIN NEW.updated_at = now(); RETURN NEW; END "
  },
  {
    "schema_name": "public",
    "function_name": "apply_blocks_to_workout",
    "arguments": "p_daily_workout_id bigint",
    "return_type": "void",
    "function_definition": "CREATE OR REPLACE FUNCTION public.apply_blocks_to_workout(p_daily_workout_id bigint)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\ndeclare\n  blk record;\n  itm record;\n  seq_base int;\n  payload jsonb;\nbegin\n  -- Idempotent: clear any previously materialized rows\n  delete from public.daily_workout_movements\n   where daily_workout_id = p_daily_workout_id;\n\n  -- For each selected block (one per type), in display order\n  for blk in\n    select b.block_type, b.block_id, b.variant\n      from public.daily_workout_blocks b\n     where b.daily_workout_id = p_daily_workout_id\n     order by case b.block_type\n                when 'prep' then 1\n                when 'build' then 2\n                when 'capacity' then 3\n                else 4\n              end\n  loop\n    seq_base := case blk.block_type\n                  when 'prep' then 100\n                  when 'build' then 200\n                  when 'capacity' then 300\n                  else 400\n                end;\n\n    -- Pull items and movement defaults; select the chosen variant payload\n    for itm in\n      select\n        i.sequence,\n        i.movement_uuid,\n        (i.variants -> blk.variant)        as v_payload,\n        m.default_modifiers,\n        m.default_metrics,\n        m.default_sport_impact_vector,\n        m.default_module_impact_vector\n      from public.movement_block_items i\n      left join public.movements m on m.id = i.movement_uuid\n     where i.block_id = blk.block_id\n     order by i.sequence\n    loop\n      if itm.v_payload is null then\n        raise exception 'Block % item % is missing variant key %', blk.block_id, itm.sequence, blk.variant;\n      end if;\n\n      -- Merge prescription with movement defaults\n      payload :=\n        coalesce(itm.v_payload, '{}'::jsonb)\n        || coalesce(itm.default_modifiers, '{}'::jsonb)\n        || case when itm.default_metrics is not null\n                then jsonb_build_object('metrics', itm.default_metrics)\n                else '{}'::jsonb end\n        || case when itm.default_sport_impact_vector is not null\n                then jsonb_build_object('sport_vector', itm.default_sport_impact_vector)\n                else '{}'::jsonb end;\n\n      insert into public.daily_workout_movements\n        (daily_workout_id,\n         movement_id,              -- canonical uuid\n         sequence,\n         status,\n         assigned_intensity,\n         source_movement_id)\n      values\n        (p_daily_workout_id,\n         itm.movement_uuid,\n         seq_base + itm.sequence,\n         'pending',\n         payload,\n         itm.movement_uuid);\n    end loop;\n  end loop;\n\n  -- Enforce NOT NULL after successful materialization\n  alter table public.daily_workout_movements\n    alter column movement_id set not null;\nend\n$function$\n",
    "source_code": "\ndeclare\n  blk record;\n  itm record;\n  seq_base int;\n  payload jsonb;\nbegin\n  -- Idempotent: clear any previously materialized rows\n  delete from public.daily_workout_movements\n   where daily_workout_id = p_daily_workout_id;\n\n  -- For each selected block (one per type), in display order\n  for blk in\n    select b.block_type, b.block_id, b.variant\n      from public.daily_workout_blocks b\n     where b.daily_workout_id = p_daily_workout_id\n     order by case b.block_type\n                when 'prep' then 1\n                when 'build' then 2\n                when 'capacity' then 3\n                else 4\n              end\n  loop\n    seq_base := case blk.block_type\n                  when 'prep' then 100\n                  when 'build' then 200\n                  when 'capacity' then 300\n                  else 400\n                end;\n\n    -- Pull items and movement defaults; select the chosen variant payload\n    for itm in\n      select\n        i.sequence,\n        i.movement_uuid,\n        (i.variants -> blk.variant)        as v_payload,\n        m.default_modifiers,\n        m.default_metrics,\n        m.default_sport_impact_vector,\n        m.default_module_impact_vector\n      from public.movement_block_items i\n      left join public.movements m on m.id = i.movement_uuid\n     where i.block_id = blk.block_id\n     order by i.sequence\n    loop\n      if itm.v_payload is null then\n        raise exception 'Block % item % is missing variant key %', blk.block_id, itm.sequence, blk.variant;\n      end if;\n\n      -- Merge prescription with movement defaults\n      payload :=\n        coalesce(itm.v_payload, '{}'::jsonb)\n        || coalesce(itm.default_modifiers, '{}'::jsonb)\n        || case when itm.default_metrics is not null\n                then jsonb_build_object('metrics', itm.default_metrics)\n                else '{}'::jsonb end\n        || case when itm.default_sport_impact_vector is not null\n                then jsonb_build_object('sport_vector', itm.default_sport_impact_vector)\n                else '{}'::jsonb end;\n\n      insert into public.daily_workout_movements\n        (daily_workout_id,\n         movement_id,              -- canonical uuid\n         sequence,\n         status,\n         assigned_intensity,\n         source_movement_id)\n      values\n        (p_daily_workout_id,\n         itm.movement_uuid,\n         seq_base + itm.sequence,\n         'pending',\n         payload,\n         itm.movement_uuid);\n    end loop;\n  end loop;\n\n  -- Enforce NOT NULL after successful materialization\n  alter table public.daily_workout_movements\n    alter column movement_id set not null;\nend\n"
  },
  {
    "schema_name": "public",
    "function_name": "assign_seed_blocks_and_materialize",
    "arguments": "p_daily_workout_id bigint, p_prep_variant text DEFAULT 'base'::text, p_build_variant text DEFAULT 'base'::text, p_capacity_variant text DEFAULT 'base'::text, p_finish_variant text DEFAULT 'base'::text, p_pick_strategy text DEFAULT 'random'::text",
    "return_type": "TABLE(block_type text, block_id uuid, variant text)",
    "function_definition": "CREATE OR REPLACE FUNCTION public.assign_seed_blocks_and_materialize(p_daily_workout_id bigint, p_prep_variant text DEFAULT 'base'::text, p_build_variant text DEFAULT 'base'::text, p_capacity_variant text DEFAULT 'base'::text, p_finish_variant text DEFAULT 'base'::text, p_pick_strategy text DEFAULT 'random'::text)\n RETURNS TABLE(block_type text, block_id uuid, variant text)\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nDECLARE\n  v_prep     uuid;\n  v_build    uuid;\n  v_capacity uuid;\n  v_finish   uuid;\nBEGIN\n  -- validate workout exists\n  PERFORM 1 FROM public.daily_workouts WHERE id = p_daily_workout_id;\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'daily_workouts.id % does not exist', p_daily_workout_id;\n  END IF;\n\n  -- validate variants\n  IF p_prep_variant NOT IN ('low_impact','base','advanced') THEN\n    RAISE EXCEPTION 'Invalid prep variant \"%\". Use low_impact|base|advanced.', p_prep_variant;\n  END IF;\n  IF p_build_variant NOT IN ('low_impact','base','advanced') THEN\n    RAISE EXCEPTION 'Invalid build variant \"%\". Use low_impact|base|advanced.', p_build_variant;\n  END IF;\n  IF p_capacity_variant NOT IN ('low_impact','base','advanced') THEN\n    RAISE EXCEPTION 'Invalid capacity variant \"%\". Use low_impact|base|advanced.', p_capacity_variant;\n  END IF;\n  IF p_finish_variant NOT IN ('low_impact','base','advanced') THEN\n    RAISE EXCEPTION 'Invalid finish variant \"%\". Use low_impact|base|advanced.', p_finish_variant;\n  END IF;\n\n  -- validate pick strategy\n  IF p_pick_strategy NOT IN ('random','first') THEN\n    RAISE EXCEPTION 'Invalid pick strategy \"%\". Use random|first.', p_pick_strategy;\n  END IF;\n\n  -- pick one block per type from the seed set (QUALIFY column with alias \"b\")\n  SELECT id INTO v_prep\n  FROM public.movement_blocks b\n  WHERE b.notes='seed:blocks_v1' AND b.block_type='prep'\n  ORDER BY CASE WHEN p_pick_strategy='random' THEN random() ELSE b.id::text END\n  LIMIT 1;\n\n  SELECT id INTO v_build\n  FROM public.movement_blocks b\n  WHERE b.notes='seed:blocks_v1' AND b.block_type='build'\n  ORDER BY CASE WHEN p_pick_strategy='random' THEN random() ELSE b.id::text END\n  LIMIT 1;\n\n  SELECT id INTO v_capacity\n  FROM public.movement_blocks b\n  WHERE b.notes='seed:blocks_v1' AND b.block_type='capacity'\n  ORDER BY CASE WHEN p_pick_strategy='random' THEN random() ELSE b.id::text END\n  LIMIT 1;\n\n  SELECT id INTO v_finish\n  FROM public.movement_blocks b\n  WHERE b.notes='seed:blocks_v1' AND b.block_type='finish'\n  ORDER BY CASE WHEN p_pick_strategy='random' THEN random() ELSE b.id::text END\n  LIMIT 1;\n\n  IF v_prep IS NULL OR v_build IS NULL OR v_capacity IS NULL OR v_finish IS NULL THEN\n    RAISE EXCEPTION 'Seed blocks missing. Did you run the seed script (notes=seed:blocks_v1)?';\n  END IF;\n\n  -- upsert selections (one block per type per day)\n  INSERT INTO public.daily_workout_blocks (daily_workout_id, block_type, block_id, variant)\n  VALUES\n    (p_daily_workout_id, 'prep',     v_prep,     p_prep_variant),\n    (p_daily_workout_id, 'build',    v_build,    p_build_variant),\n    (p_daily_workout_id, 'capacity', v_capacity, p_capacity_variant),\n    (p_daily_workout_id, 'finish',   v_finish,   p_finish_variant)\n  ON CONFLICT (daily_workout_id, block_type) DO UPDATE\n  SET block_id = EXCLUDED.block_id,\n      variant  = EXCLUDED.variant;\n\n  -- snapshot movements for the day (idempotent)\n  PERFORM public.materialize_daily_workout_movements(p_daily_workout_id, true);\n\n  -- return what we assigned\n  RETURN QUERY\n  SELECT * FROM (VALUES\n    ('prep',     v_prep,     p_prep_variant),\n    ('build',    v_build,    p_build_variant),\n    ('capacity', v_capacity, p_capacity_variant),\n    ('finish',   v_finish,   p_finish_variant)\n  ) AS t(block_type, block_id, variant);\nEND $function$\n",
    "source_code": "\nDECLARE\n  v_prep     uuid;\n  v_build    uuid;\n  v_capacity uuid;\n  v_finish   uuid;\nBEGIN\n  -- validate workout exists\n  PERFORM 1 FROM public.daily_workouts WHERE id = p_daily_workout_id;\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'daily_workouts.id % does not exist', p_daily_workout_id;\n  END IF;\n\n  -- validate variants\n  IF p_prep_variant NOT IN ('low_impact','base','advanced') THEN\n    RAISE EXCEPTION 'Invalid prep variant \"%\". Use low_impact|base|advanced.', p_prep_variant;\n  END IF;\n  IF p_build_variant NOT IN ('low_impact','base','advanced') THEN\n    RAISE EXCEPTION 'Invalid build variant \"%\". Use low_impact|base|advanced.', p_build_variant;\n  END IF;\n  IF p_capacity_variant NOT IN ('low_impact','base','advanced') THEN\n    RAISE EXCEPTION 'Invalid capacity variant \"%\". Use low_impact|base|advanced.', p_capacity_variant;\n  END IF;\n  IF p_finish_variant NOT IN ('low_impact','base','advanced') THEN\n    RAISE EXCEPTION 'Invalid finish variant \"%\". Use low_impact|base|advanced.', p_finish_variant;\n  END IF;\n\n  -- validate pick strategy\n  IF p_pick_strategy NOT IN ('random','first') THEN\n    RAISE EXCEPTION 'Invalid pick strategy \"%\". Use random|first.', p_pick_strategy;\n  END IF;\n\n  -- pick one block per type from the seed set (QUALIFY column with alias \"b\")\n  SELECT id INTO v_prep\n  FROM public.movement_blocks b\n  WHERE b.notes='seed:blocks_v1' AND b.block_type='prep'\n  ORDER BY CASE WHEN p_pick_strategy='random' THEN random() ELSE b.id::text END\n  LIMIT 1;\n\n  SELECT id INTO v_build\n  FROM public.movement_blocks b\n  WHERE b.notes='seed:blocks_v1' AND b.block_type='build'\n  ORDER BY CASE WHEN p_pick_strategy='random' THEN random() ELSE b.id::text END\n  LIMIT 1;\n\n  SELECT id INTO v_capacity\n  FROM public.movement_blocks b\n  WHERE b.notes='seed:blocks_v1' AND b.block_type='capacity'\n  ORDER BY CASE WHEN p_pick_strategy='random' THEN random() ELSE b.id::text END\n  LIMIT 1;\n\n  SELECT id INTO v_finish\n  FROM public.movement_blocks b\n  WHERE b.notes='seed:blocks_v1' AND b.block_type='finish'\n  ORDER BY CASE WHEN p_pick_strategy='random' THEN random() ELSE b.id::text END\n  LIMIT 1;\n\n  IF v_prep IS NULL OR v_build IS NULL OR v_capacity IS NULL OR v_finish IS NULL THEN\n    RAISE EXCEPTION 'Seed blocks missing. Did you run the seed script (notes=seed:blocks_v1)?';\n  END IF;\n\n  -- upsert selections (one block per type per day)\n  INSERT INTO public.daily_workout_blocks (daily_workout_id, block_type, block_id, variant)\n  VALUES\n    (p_daily_workout_id, 'prep',     v_prep,     p_prep_variant),\n    (p_daily_workout_id, 'build',    v_build,    p_build_variant),\n    (p_daily_workout_id, 'capacity', v_capacity, p_capacity_variant),\n    (p_daily_workout_id, 'finish',   v_finish,   p_finish_variant)\n  ON CONFLICT (daily_workout_id, block_type) DO UPDATE\n  SET block_id = EXCLUDED.block_id,\n      variant  = EXCLUDED.variant;\n\n  -- snapshot movements for the day (idempotent)\n  PERFORM public.materialize_daily_workout_movements(p_daily_workout_id, true);\n\n  -- return what we assigned\n  RETURN QUERY\n  SELECT * FROM (VALUES\n    ('prep',     v_prep,     p_prep_variant),\n    ('build',    v_build,    p_build_variant),\n    ('capacity', v_capacity, p_capacity_variant),\n    ('finish',   v_finish,   p_finish_variant)\n  ) AS t(block_type, block_id, variant);\nEND "
  },
  {
    "schema_name": "public",
    "function_name": "blocks_validate_goal_vector",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.blocks_validate_goal_vector()\n RETURNS trigger\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nDECLARE\n  expected_count int;\n  key_count      int;\n  missing_count  int;\n  extra_count    int;\nBEGIN\n  -- how many goals exist right now?\n  SELECT count(*) INTO expected_count FROM public.goals;\n\n  -- count keys present in the incoming JSON object\n  SELECT count(*) INTO key_count\n  FROM jsonb_object_keys(NEW.goal_impact_vector);\n\n  -- how many goal ids are missing from the JSON?\n  SELECT count(*) INTO missing_count\n  FROM public.goals g\n  WHERE NOT (NEW.goal_impact_vector ? g.id::text);\n\n  -- how many extra (non-goal) keys are present?\n  SELECT count(*) INTO extra_count\n  FROM jsonb_object_keys(NEW.goal_impact_vector) AS k(key)\n  LEFT JOIN public.goals g ON g.id::text = k.key\n  WHERE g.id IS NULL;\n\n  IF COALESCE(jsonb_typeof(NEW.goal_impact_vector), '') <> 'object'\n     OR key_count <> expected_count\n     OR missing_count > 0\n     OR extra_count > 0\n  THEN\n    RAISE EXCEPTION\n      'goal_impact_vector must include exactly the current public.goals ids; expected=%, found_keys=%, missing=%, extra=%',\n      expected_count, key_count, missing_count, extra_count\n      USING HINT = 'Run public.rebuild_block_goal_vectors() after editing public.goals.';\n  END IF;\n\n  RETURN NEW;\nEND $function$\n",
    "source_code": "\nDECLARE\n  expected_count int;\n  key_count      int;\n  missing_count  int;\n  extra_count    int;\nBEGIN\n  -- how many goals exist right now?\n  SELECT count(*) INTO expected_count FROM public.goals;\n\n  -- count keys present in the incoming JSON object\n  SELECT count(*) INTO key_count\n  FROM jsonb_object_keys(NEW.goal_impact_vector);\n\n  -- how many goal ids are missing from the JSON?\n  SELECT count(*) INTO missing_count\n  FROM public.goals g\n  WHERE NOT (NEW.goal_impact_vector ? g.id::text);\n\n  -- how many extra (non-goal) keys are present?\n  SELECT count(*) INTO extra_count\n  FROM jsonb_object_keys(NEW.goal_impact_vector) AS k(key)\n  LEFT JOIN public.goals g ON g.id::text = k.key\n  WHERE g.id IS NULL;\n\n  IF COALESCE(jsonb_typeof(NEW.goal_impact_vector), '') <> 'object'\n     OR key_count <> expected_count\n     OR missing_count > 0\n     OR extra_count > 0\n  THEN\n    RAISE EXCEPTION\n      'goal_impact_vector must include exactly the current public.goals ids; expected=%, found_keys=%, missing=%, extra=%',\n      expected_count, key_count, missing_count, extra_count\n      USING HINT = 'Run public.rebuild_block_goal_vectors() after editing public.goals.';\n  END IF;\n\n  RETURN NEW;\nEND "
  },
  {
    "schema_name": "public",
    "function_name": "compute_default_sport_vector",
    "arguments": "p_pattern_name text, p_pattern_type text, p_movement_name text",
    "return_type": "jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION public.compute_default_sport_vector(p_pattern_name text, p_pattern_type text, p_movement_name text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\ndeclare\n  t   text := lower(coalesce(p_pattern_type,''));\n  pn  text := lower(coalesce(p_pattern_name,''));\n  mn  text := lower(coalesce(p_movement_name,''));\n  v   jsonb;\nbegin\n  if t = 'strength' then\n    v := jsonb_build_object(\n      'Soccer',0.45,'Basketball',0.50,'Football',0.70,'Tennis',0.45,\n      'Short distance running',0.55,'Mid distance running',0.35,'Long distance running',0.30,\n      'Triathlons',0.35,'Crossfit',0.60,'Hyrox',0.60\n    );\n  elsif t = 'endurance' then\n    v := jsonb_build_object(\n      'Soccer',0.60,'Basketball',0.55,'Football',0.40,'Tennis',0.55,\n      'Short distance running',0.65,'Mid distance running',0.75,'Long distance running',0.85,\n      'Triathlons',0.80,'Crossfit',0.60,'Hyrox',0.65\n    );\n  elsif t = 'mobility' then\n    v := jsonb_build_object(\n      'Soccer',0.50,'Basketball',0.50,'Football',0.45,'Tennis',0.50,\n      'Short distance running',0.45,'Mid distance running',0.45,'Long distance running',0.45,\n      'Triathlons',0.45,'Crossfit',0.45,'Hyrox',0.45\n    );\n  elsif t = 'stability' then\n    v := jsonb_build_object(\n      'Soccer',0.55,'Basketball',0.55,'Football',0.60,'Tennis',0.55,\n      'Short distance running',0.45,'Mid distance running',0.40,'Long distance running',0.35,\n      'Triathlons',0.40,'Crossfit',0.65,'Hyrox',0.55\n    );\n  else\n    v := jsonb_build_object(\n      'Soccer',0.50,'Basketball',0.50,'Football',0.50,'Tennis',0.50,\n      'Short distance running',0.50,'Mid distance running',0.50,'Long distance running',0.50,\n      'Triathlons',0.50,'Crossfit',0.50,'Hyrox',0.50\n    );\n  end if;\n\n  -- pattern overrides (same as before)\n  if pn like 'gait / locomotion%' then\n    if mn like 'walk%' then\n      v := v || jsonb_build_object('Short distance running',0.30,'Mid distance running',0.35,'Long distance running',0.40,'Triathlons',0.30);\n    elsif mn like 'jog%' then\n      v := v || jsonb_build_object('Mid distance running',0.70,'Long distance running',0.60,'Triathlons',0.60);\n    elsif mn = 'run' then\n      v := v || jsonb_build_object('Mid distance running',0.75,'Long distance running',0.70,'Triathlons',0.65);\n    elsif mn like 'sprint%' then\n      v := v || jsonb_build_object('Short distance running',0.90,'Soccer',0.70,'Basketball',0.60,'Hyrox',0.60,'Crossfit',0.60);\n    end if;\n  end if;\n\n  if pn like 'carry / load transport%' then\n    v := v || jsonb_build_object('Hyrox',0.90,'Crossfit',0.75,'Football',0.70);\n  end if;\n\n  if pn like 'cyclic lower body%' then\n    v := v || jsonb_build_object('Triathlons',0.70,'Mid distance running',0.70,'Long distance running',0.60);\n  end if;\n\n  if pn like 'mixed modal conditioning%' then\n    v := v || jsonb_build_object('Crossfit',0.90,'Hyrox',0.85,'Soccer',0.60,'Basketball',0.60);\n  end if;\n\n  if pn like 'swimming / aquatic locomotion%' or mn like '%swim%' then\n    v := v || jsonb_build_object('Triathlons',0.85,'Short distance running',0.30,'Mid distance running',0.30,'Long distance running',0.30);\n  end if;\n\n  if mn like '%sled push%' then\n    v := v || jsonb_build_object('Hyrox',0.95,'Crossfit',0.80,'Short distance running',0.70,'Football',0.70);\n  end if;\n  if mn like '%rowing erg%' then\n    v := v || jsonb_build_object('Crossfit',0.70,'Hyrox',0.60,'Triathlons',0.35);\n  end if;\n  if mn like '%burpee%' then\n    v := v || jsonb_build_object('Crossfit',0.85,'Hyrox',0.70);\n  end if;\n  if mn like '%shuttle run with push-up%' then\n    v := v || jsonb_build_object('Short distance running',0.70,'Crossfit',0.75,'Hyrox',0.70);\n  end if;\n  if mn like '%bear crawl%' then\n    v := v || jsonb_build_object('Crossfit',0.70,'Hyrox',0.60);\n  end if;\n\n  return v;\nend $function$\n",
    "source_code": "\ndeclare\n  t   text := lower(coalesce(p_pattern_type,''));\n  pn  text := lower(coalesce(p_pattern_name,''));\n  mn  text := lower(coalesce(p_movement_name,''));\n  v   jsonb;\nbegin\n  if t = 'strength' then\n    v := jsonb_build_object(\n      'Soccer',0.45,'Basketball',0.50,'Football',0.70,'Tennis',0.45,\n      'Short distance running',0.55,'Mid distance running',0.35,'Long distance running',0.30,\n      'Triathlons',0.35,'Crossfit',0.60,'Hyrox',0.60\n    );\n  elsif t = 'endurance' then\n    v := jsonb_build_object(\n      'Soccer',0.60,'Basketball',0.55,'Football',0.40,'Tennis',0.55,\n      'Short distance running',0.65,'Mid distance running',0.75,'Long distance running',0.85,\n      'Triathlons',0.80,'Crossfit',0.60,'Hyrox',0.65\n    );\n  elsif t = 'mobility' then\n    v := jsonb_build_object(\n      'Soccer',0.50,'Basketball',0.50,'Football',0.45,'Tennis',0.50,\n      'Short distance running',0.45,'Mid distance running',0.45,'Long distance running',0.45,\n      'Triathlons',0.45,'Crossfit',0.45,'Hyrox',0.45\n    );\n  elsif t = 'stability' then\n    v := jsonb_build_object(\n      'Soccer',0.55,'Basketball',0.55,'Football',0.60,'Tennis',0.55,\n      'Short distance running',0.45,'Mid distance running',0.40,'Long distance running',0.35,\n      'Triathlons',0.40,'Crossfit',0.65,'Hyrox',0.55\n    );\n  else\n    v := jsonb_build_object(\n      'Soccer',0.50,'Basketball',0.50,'Football',0.50,'Tennis',0.50,\n      'Short distance running',0.50,'Mid distance running',0.50,'Long distance running',0.50,\n      'Triathlons',0.50,'Crossfit',0.50,'Hyrox',0.50\n    );\n  end if;\n\n  -- pattern overrides (same as before)\n  if pn like 'gait / locomotion%' then\n    if mn like 'walk%' then\n      v := v || jsonb_build_object('Short distance running',0.30,'Mid distance running',0.35,'Long distance running',0.40,'Triathlons',0.30);\n    elsif mn like 'jog%' then\n      v := v || jsonb_build_object('Mid distance running',0.70,'Long distance running',0.60,'Triathlons',0.60);\n    elsif mn = 'run' then\n      v := v || jsonb_build_object('Mid distance running',0.75,'Long distance running',0.70,'Triathlons',0.65);\n    elsif mn like 'sprint%' then\n      v := v || jsonb_build_object('Short distance running',0.90,'Soccer',0.70,'Basketball',0.60,'Hyrox',0.60,'Crossfit',0.60);\n    end if;\n  end if;\n\n  if pn like 'carry / load transport%' then\n    v := v || jsonb_build_object('Hyrox',0.90,'Crossfit',0.75,'Football',0.70);\n  end if;\n\n  if pn like 'cyclic lower body%' then\n    v := v || jsonb_build_object('Triathlons',0.70,'Mid distance running',0.70,'Long distance running',0.60);\n  end if;\n\n  if pn like 'mixed modal conditioning%' then\n    v := v || jsonb_build_object('Crossfit',0.90,'Hyrox',0.85,'Soccer',0.60,'Basketball',0.60);\n  end if;\n\n  if pn like 'swimming / aquatic locomotion%' or mn like '%swim%' then\n    v := v || jsonb_build_object('Triathlons',0.85,'Short distance running',0.30,'Mid distance running',0.30,'Long distance running',0.30);\n  end if;\n\n  if mn like '%sled push%' then\n    v := v || jsonb_build_object('Hyrox',0.95,'Crossfit',0.80,'Short distance running',0.70,'Football',0.70);\n  end if;\n  if mn like '%rowing erg%' then\n    v := v || jsonb_build_object('Crossfit',0.70,'Hyrox',0.60,'Triathlons',0.35);\n  end if;\n  if mn like '%burpee%' then\n    v := v || jsonb_build_object('Crossfit',0.85,'Hyrox',0.70);\n  end if;\n  if mn like '%shuttle run with push-up%' then\n    v := v || jsonb_build_object('Short distance running',0.70,'Crossfit',0.75,'Hyrox',0.70);\n  end if;\n  if mn like '%bear crawl%' then\n    v := v || jsonb_build_object('Crossfit',0.70,'Hyrox',0.60);\n  end if;\n\n  return v;\nend "
  },
  {
    "schema_name": "public",
    "function_name": "json_keys_exist_in_modules",
    "arguments": "vec jsonb",
    "return_type": "boolean",
    "function_definition": "CREATE OR REPLACE FUNCTION public.json_keys_exist_in_modules(vec jsonb)\n RETURNS boolean\n LANGUAGE sql\n STABLE\nAS $function$\n  SELECT NOT EXISTS (\n    SELECT 1\n    FROM jsonb_object_keys(vec) k\n    LEFT JOIN public.modules m ON m.id::text = k\n    WHERE m.id IS NULL\n  );\n$function$\n",
    "source_code": "\n  SELECT NOT EXISTS (\n    SELECT 1\n    FROM jsonb_object_keys(vec) k\n    LEFT JOIN public.modules m ON m.id::text = k\n    WHERE m.id IS NULL\n  );\n"
  },
  {
    "schema_name": "public",
    "function_name": "json_score_object_in_range",
    "arguments": "vec jsonb, lo numeric, hi numeric",
    "return_type": "boolean",
    "function_definition": "CREATE OR REPLACE FUNCTION public.json_score_object_in_range(vec jsonb, lo numeric, hi numeric)\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n  SELECT\n    jsonb_typeof(vec) = 'object'\n    AND NOT EXISTS (\n      SELECT 1\n      FROM jsonb_each(vec) e(k, v)\n      WHERE jsonb_typeof(v) NOT IN ('number','integer')\n         OR (v::text)::numeric < lo\n         OR (v::text)::numeric > hi\n    );\n$function$\n",
    "source_code": "\n  SELECT\n    jsonb_typeof(vec) = 'object'\n    AND NOT EXISTS (\n      SELECT 1\n      FROM jsonb_each(vec) e(k, v)\n      WHERE jsonb_typeof(v) NOT IN ('number','integer')\n         OR (v::text)::numeric < lo\n         OR (v::text)::numeric > hi\n    );\n"
  },
  {
    "schema_name": "public",
    "function_name": "materialize_daily_workout_movements",
    "arguments": "p_daily_workout_id bigint, p_reset boolean DEFAULT true",
    "return_type": "integer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.materialize_daily_workout_movements(p_daily_workout_id bigint, p_reset boolean DEFAULT true)\n RETURNS integer\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nDECLARE\n  v_exists boolean;\n  v_rows   integer;\nBEGIN\n  -- 0) Verify the workout exists (FK would catch on insert, but fail early is cleaner)\n  SELECT TRUE INTO v_exists\n  FROM public.daily_workouts\n  WHERE id = p_daily_workout_id;\n  IF NOT v_exists THEN\n    RAISE EXCEPTION 'daily_workouts.id % does not exist', p_daily_workout_id;\n  END IF;\n\n  -- 1) Optionally clear any previous snapshot for this day (idempotent rebuild)\n  IF p_reset THEN\n    DELETE FROM public.daily_workout_movements\n    WHERE daily_workout_id = p_daily_workout_id;\n  END IF;\n\n  -- 2) Ensure there are blocks attached (one per type at most, enforced elsewhere)\n  PERFORM 1\n  FROM public.daily_workout_blocks\n  WHERE daily_workout_id = p_daily_workout_id;\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'No blocks assigned for daily_workout_id %, cannot materialize', p_daily_workout_id;\n  END IF;\n\n  -- 3) Insert snapshot: expand the chosen variant and order items across the day\n  WITH expanded AS (\n    SELECT\n      d.block_type,\n      d.variant,\n      i.sequence          AS item_seq,\n      i.movement_uuid     AS movement_id\n    FROM public.daily_workout_blocks d\n    JOIN public.movement_block_items i\n      ON i.block_id = d.block_id\n     AND (i.variants ? d.variant)\n     AND (i.variants->>d.variant)::boolean = TRUE\n    WHERE d.daily_workout_id = p_daily_workout_id\n  ),\n  ordered AS (\n    SELECT\n      ROW_NUMBER() OVER (\n        ORDER BY\n          CASE block_type\n            WHEN 'prep' THEN 1\n            WHEN 'build' THEN 2\n            WHEN 'capacity' THEN 3\n            WHEN 'finish' THEN 4\n          END,\n          item_seq\n      ) AS seq,\n      movement_id\n    FROM expanded\n  )\n  INSERT INTO public.daily_workout_movements (\n    daily_workout_id,\n    sequence,\n    status,\n    assigned_intensity,\n    recovery_impact_score,\n    resilience_impact_score,\n    results_impact_score,\n    movement_id,\n    source_movement_id\n  )\n  SELECT\n    p_daily_workout_id,\n    o.seq,\n    'pending',        -- default starting state\n    NULL, NULL, NULL, NULL,\n    o.movement_id,    -- assigned\n    o.movement_id     -- provenance (template); change this ONLY if you want to point at a different template\n  FROM ordered o\n  RETURNING 1\n  INTO v_rows;\n\n  GET DIAGNOSTICS v_rows = ROW_COUNT;\n  IF v_rows = 0 THEN\n    RAISE EXCEPTION 'No block items matched the chosen variants for daily_workout_id %', p_daily_workout_id;\n  END IF;\n\n  RETURN v_rows;\nEND $function$\n",
    "source_code": "\nDECLARE\n  v_exists boolean;\n  v_rows   integer;\nBEGIN\n  -- 0) Verify the workout exists (FK would catch on insert, but fail early is cleaner)\n  SELECT TRUE INTO v_exists\n  FROM public.daily_workouts\n  WHERE id = p_daily_workout_id;\n  IF NOT v_exists THEN\n    RAISE EXCEPTION 'daily_workouts.id % does not exist', p_daily_workout_id;\n  END IF;\n\n  -- 1) Optionally clear any previous snapshot for this day (idempotent rebuild)\n  IF p_reset THEN\n    DELETE FROM public.daily_workout_movements\n    WHERE daily_workout_id = p_daily_workout_id;\n  END IF;\n\n  -- 2) Ensure there are blocks attached (one per type at most, enforced elsewhere)\n  PERFORM 1\n  FROM public.daily_workout_blocks\n  WHERE daily_workout_id = p_daily_workout_id;\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'No blocks assigned for daily_workout_id %, cannot materialize', p_daily_workout_id;\n  END IF;\n\n  -- 3) Insert snapshot: expand the chosen variant and order items across the day\n  WITH expanded AS (\n    SELECT\n      d.block_type,\n      d.variant,\n      i.sequence          AS item_seq,\n      i.movement_uuid     AS movement_id\n    FROM public.daily_workout_blocks d\n    JOIN public.movement_block_items i\n      ON i.block_id = d.block_id\n     AND (i.variants ? d.variant)\n     AND (i.variants->>d.variant)::boolean = TRUE\n    WHERE d.daily_workout_id = p_daily_workout_id\n  ),\n  ordered AS (\n    SELECT\n      ROW_NUMBER() OVER (\n        ORDER BY\n          CASE block_type\n            WHEN 'prep' THEN 1\n            WHEN 'build' THEN 2\n            WHEN 'capacity' THEN 3\n            WHEN 'finish' THEN 4\n          END,\n          item_seq\n      ) AS seq,\n      movement_id\n    FROM expanded\n  )\n  INSERT INTO public.daily_workout_movements (\n    daily_workout_id,\n    sequence,\n    status,\n    assigned_intensity,\n    recovery_impact_score,\n    resilience_impact_score,\n    results_impact_score,\n    movement_id,\n    source_movement_id\n  )\n  SELECT\n    p_daily_workout_id,\n    o.seq,\n    'pending',        -- default starting state\n    NULL, NULL, NULL, NULL,\n    o.movement_id,    -- assigned\n    o.movement_id     -- provenance (template); change this ONLY if you want to point at a different template\n  FROM ordered o\n  RETURNING 1\n  INTO v_rows;\n\n  GET DIAGNOSTICS v_rows = ROW_COUNT;\n  IF v_rows = 0 THEN\n    RAISE EXCEPTION 'No block items matched the chosen variants for daily_workout_id %', p_daily_workout_id;\n  END IF;\n\n  RETURN v_rows;\nEND "
  },
  {
    "schema_name": "public",
    "function_name": "movements_normalize_and_validate_dose_ids",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.movements_normalize_and_validate_dose_ids()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  invalid_cnt integer;\n  normalized uuid[];\nBEGIN\n  IF NEW.allowed_dose_metric_ids IS NULL THEN\n    NEW.allowed_dose_metric_ids := '{}'::uuid[];\n  END IF;\n\n  -- dedupe + sort for stability\n  SELECT COALESCE(array_agg(u ORDER BY u), '{}') INTO normalized\n  FROM (SELECT DISTINCT unnest(NEW.allowed_dose_metric_ids) AS u) s;\n  NEW.allowed_dose_metric_ids := normalized;\n\n  -- ensure every id exists in public.dose_metrics\n  SELECT COUNT(*) INTO invalid_cnt\n  FROM unnest(NEW.allowed_dose_metric_ids) AS d(id)\n  LEFT JOIN public.dose_metrics m ON m.id = d.id\n  WHERE m.id IS NULL;\n\n  IF invalid_cnt > 0 THEN\n    RAISE EXCEPTION 'allowed_dose_metric_ids contains IDs not found in public.dose_metrics';\n  END IF;\n\n  RETURN NEW;\nEND;\n$function$\n",
    "source_code": "\nDECLARE\n  invalid_cnt integer;\n  normalized uuid[];\nBEGIN\n  IF NEW.allowed_dose_metric_ids IS NULL THEN\n    NEW.allowed_dose_metric_ids := '{}'::uuid[];\n  END IF;\n\n  -- dedupe + sort for stability\n  SELECT COALESCE(array_agg(u ORDER BY u), '{}') INTO normalized\n  FROM (SELECT DISTINCT unnest(NEW.allowed_dose_metric_ids) AS u) s;\n  NEW.allowed_dose_metric_ids := normalized;\n\n  -- ensure every id exists in public.dose_metrics\n  SELECT COUNT(*) INTO invalid_cnt\n  FROM unnest(NEW.allowed_dose_metric_ids) AS d(id)\n  LEFT JOIN public.dose_metrics m ON m.id = d.id\n  WHERE m.id IS NULL;\n\n  IF invalid_cnt > 0 THEN\n    RAISE EXCEPTION 'allowed_dose_metric_ids contains IDs not found in public.dose_metrics';\n  END IF;\n\n  RETURN NEW;\nEND;\n"
  },
  {
    "schema_name": "public",
    "function_name": "movements_required_equipment_guard",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.movements_required_equipment_guard()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n    DECLARE\n      missing_ct int;\n    BEGIN\n      NEW.required_equipment := public.normalize_int4_array(NEW.required_equipment);\n\n      SELECT COUNT(*)\n      INTO missing_ct\n      FROM (\n        SELECT x.eid\n        FROM unnest(COALESCE(NEW.required_equipment, '{}'::int4[])) AS x(eid)\n        LEFT JOIN public.equipment eq ON eq.id = x.eid\n        WHERE eq.id IS NULL\n      ) AS m;\n\n      IF missing_ct > 0 THEN\n        RAISE EXCEPTION 'required_equipment contains unknown equipment id(s)';\n      END IF;\n\n      RETURN NEW;\n    END;\n    $function$\n",
    "source_code": "\n    DECLARE\n      missing_ct int;\n    BEGIN\n      NEW.required_equipment := public.normalize_int4_array(NEW.required_equipment);\n\n      SELECT COUNT(*)\n      INTO missing_ct\n      FROM (\n        SELECT x.eid\n        FROM unnest(COALESCE(NEW.required_equipment, '{}'::int4[])) AS x(eid)\n        LEFT JOIN public.equipment eq ON eq.id = x.eid\n        WHERE eq.id IS NULL\n      ) AS m;\n\n      IF missing_ct > 0 THEN\n        RAISE EXCEPTION 'required_equipment contains unknown equipment id(s)';\n      END IF;\n\n      RETURN NEW;\n    END;\n    "
  },
  {
    "schema_name": "public",
    "function_name": "movements_sanitize_injury_flags",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.movements_sanitize_injury_flags()\n RETURNS trigger\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nDECLARE\n  badshape boolean;\n  cleaned_ind jsonb := '[]'::jsonb;\n  cleaned_con jsonb := '[]'::jsonb;\nBEGIN\n  -- Coerce nulls to the canonical empty object\n  IF NEW.default_injury_flags IS NULL THEN\n    NEW.default_injury_flags := jsonb_build_object('indication','[]'::jsonb,'contraindication','[]'::jsonb);\n  END IF;\n\n  -- Basic shape\n  badshape := NOT (\n    jsonb_typeof(NEW.default_injury_flags) = 'object'\n    AND NEW.default_injury_flags ? 'indication'\n    AND NEW.default_injury_flags ? 'contraindication'\n    AND jsonb_typeof(NEW.default_injury_flags->'indication') = 'array'\n    AND jsonb_typeof(NEW.default_injury_flags->'contraindication') = 'array'\n  );\n  IF badshape THEN\n    RAISE EXCEPTION 'default_injury_flags must be {\"indication\":[...], \"contraindication\":[...]} with arrays of ids';\n  END IF;\n\n  -- De-dup, drop non-numeric, enforce FK membership\n  WITH\n  ind AS (\n    SELECT DISTINCT v::int AS id\n    FROM jsonb_array_elements_text(NEW.default_injury_flags->'indication') e(v)\n    WHERE v ~ '^\\d+$'\n  ),\n  con AS (\n    SELECT DISTINCT v::int AS id\n    FROM jsonb_array_elements_text(NEW.default_injury_flags->'contraindication') e(v)\n    WHERE v ~ '^\\d+$'\n  ),\n  valid_ind AS (\n    SELECT i.id\n    FROM ind i JOIN public.injuries inj ON inj.id = i.id\n    EXCEPT SELECT id FROM con          -- contraindication wins\n  ),\n  valid_con AS (\n    SELECT c.id\n    FROM con c JOIN public.injuries inj ON inj.id = c.id\n  )\n  SELECT\n    COALESCE(jsonb_agg(id) FILTER (WHERE TRUE), '[]'::jsonb),\n    COALESCE(jsonb_agg(id) FILTER (WHERE TRUE), '[]'::jsonb)\n  INTO cleaned_ind, cleaned_con\n  FROM valid_ind\n  FULL JOIN valid_con USING (id);\n\n  NEW.default_injury_flags := jsonb_build_object('indication', cleaned_ind, 'contraindication', cleaned_con);\n  RETURN NEW;\nEND $function$\n",
    "source_code": "\nDECLARE\n  badshape boolean;\n  cleaned_ind jsonb := '[]'::jsonb;\n  cleaned_con jsonb := '[]'::jsonb;\nBEGIN\n  -- Coerce nulls to the canonical empty object\n  IF NEW.default_injury_flags IS NULL THEN\n    NEW.default_injury_flags := jsonb_build_object('indication','[]'::jsonb,'contraindication','[]'::jsonb);\n  END IF;\n\n  -- Basic shape\n  badshape := NOT (\n    jsonb_typeof(NEW.default_injury_flags) = 'object'\n    AND NEW.default_injury_flags ? 'indication'\n    AND NEW.default_injury_flags ? 'contraindication'\n    AND jsonb_typeof(NEW.default_injury_flags->'indication') = 'array'\n    AND jsonb_typeof(NEW.default_injury_flags->'contraindication') = 'array'\n  );\n  IF badshape THEN\n    RAISE EXCEPTION 'default_injury_flags must be {\"indication\":[...], \"contraindication\":[...]} with arrays of ids';\n  END IF;\n\n  -- De-dup, drop non-numeric, enforce FK membership\n  WITH\n  ind AS (\n    SELECT DISTINCT v::int AS id\n    FROM jsonb_array_elements_text(NEW.default_injury_flags->'indication') e(v)\n    WHERE v ~ '^\\d+$'\n  ),\n  con AS (\n    SELECT DISTINCT v::int AS id\n    FROM jsonb_array_elements_text(NEW.default_injury_flags->'contraindication') e(v)\n    WHERE v ~ '^\\d+$'\n  ),\n  valid_ind AS (\n    SELECT i.id\n    FROM ind i JOIN public.injuries inj ON inj.id = i.id\n    EXCEPT SELECT id FROM con          -- contraindication wins\n  ),\n  valid_con AS (\n    SELECT c.id\n    FROM con c JOIN public.injuries inj ON inj.id = c.id\n  )\n  SELECT\n    COALESCE(jsonb_agg(id) FILTER (WHERE TRUE), '[]'::jsonb),\n    COALESCE(jsonb_agg(id) FILTER (WHERE TRUE), '[]'::jsonb)\n  INTO cleaned_ind, cleaned_con\n  FROM valid_ind\n  FULL JOIN valid_con USING (id);\n\n  NEW.default_injury_flags := jsonb_build_object('indication', cleaned_ind, 'contraindication', cleaned_con);\n  RETURN NEW;\nEND "
  },
  {
    "schema_name": "public",
    "function_name": "movements_validate_super_metric_vector",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.movements_validate_super_metric_vector()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN NEW;\nEND;\n$function$\n",
    "source_code": "\nBEGIN\n  RETURN NEW;\nEND;\n"
  },
  {
    "schema_name": "public",
    "function_name": "normalize_int4_array",
    "arguments": "arr integer[]",
    "return_type": "integer[]",
    "function_definition": "CREATE OR REPLACE FUNCTION public.normalize_int4_array(arr integer[])\n RETURNS integer[]\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n      SELECT CASE\n               WHEN arr IS NULL THEN '{}'::int4[]\n               ELSE ARRAY(\n                 SELECT DISTINCT e\n                 FROM unnest(arr) AS e\n                 WHERE e IS NOT NULL\n                 ORDER BY 1\n               )\n             END\n    $function$\n",
    "source_code": "\n      SELECT CASE\n               WHEN arr IS NULL THEN '{}'::int4[]\n               ELSE ARRAY(\n                 SELECT DISTINCT e\n                 FROM unnest(arr) AS e\n                 WHERE e IS NOT NULL\n                 ORDER BY 1\n               )\n             END\n    "
  },
  {
    "schema_name": "public",
    "function_name": "rebuild_block_goal_vectors",
    "arguments": "",
    "return_type": "void",
    "function_definition": "CREATE OR REPLACE FUNCTION public.rebuild_block_goal_vectors()\n RETURNS void\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\n  UPDATE public.movement_blocks b\n  SET goal_impact_vector = (\n    SELECT jsonb_object_agg(\n             g.id::text,\n             to_jsonb(COALESCE( (b.goal_impact_vector->>g.id::text)::int, 0 ))\n           )\n    FROM public.goals g\n  );\n$function$\n",
    "source_code": "\n  UPDATE public.movement_blocks b\n  SET goal_impact_vector = (\n    SELECT jsonb_object_agg(\n             g.id::text,\n             to_jsonb(COALESCE( (b.goal_impact_vector->>g.id::text)::int, 0 ))\n           )\n    FROM public.goals g\n  );\n"
  },
  {
    "schema_name": "public",
    "function_name": "refresh_movement_library",
    "arguments": "",
    "return_type": "void",
    "function_definition": "CREATE OR REPLACE FUNCTION public.refresh_movement_library()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nBEGIN\n  REFRESH MATERIALIZED VIEW public.movement_library;\nEND$function$\n",
    "source_code": "\nBEGIN\n  REFRESH MATERIALIZED VIEW public.movement_library;\nEND"
  },
  {
    "schema_name": "public",
    "function_name": "set_movement_dose_metrics_by_keys",
    "arguments": "movement_name text, metric_keys text[]",
    "return_type": "void",
    "function_definition": "CREATE OR REPLACE FUNCTION public.set_movement_dose_metrics_by_keys(movement_name text, metric_keys text[])\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  ids uuid[];\nBEGIN\n  SELECT COALESCE(array_agg(m.id ORDER BY m.key), '{}')\n  INTO ids\n  FROM public.dose_metrics m\n  WHERE m.key = ANY(metric_keys);\n\n  IF array_length(ids,1) IS NULL THEN\n    RAISE EXCEPTION 'No matching dose_metrics for keys: %', metric_keys;\n  END IF;\n\n  UPDATE public.movements\n  SET allowed_dose_metric_ids = ids\n  WHERE name = movement_name;\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Movement \"%\" not found', movement_name;\n  END IF;\nEND;\n$function$\n",
    "source_code": "\nDECLARE\n  ids uuid[];\nBEGIN\n  SELECT COALESCE(array_agg(m.id ORDER BY m.key), '{}')\n  INTO ids\n  FROM public.dose_metrics m\n  WHERE m.key = ANY(metric_keys);\n\n  IF array_length(ids,1) IS NULL THEN\n    RAISE EXCEPTION 'No matching dose_metrics for keys: %', metric_keys;\n  END IF;\n\n  UPDATE public.movements\n  SET allowed_dose_metric_ids = ids\n  WHERE name = movement_name;\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Movement \"%\" not found', movement_name;\n  END IF;\nEND;\n"
  },
  {
    "schema_name": "public",
    "function_name": "set_updated_at",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.set_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n  new.updated_at := now();\n  return new;\nend;\n$function$\n",
    "source_code": "\nbegin\n  new.updated_at := now();\n  return new;\nend;\n"
  },
  {
    "schema_name": "public",
    "function_name": "sync_movements_from_library",
    "arguments": "",
    "return_type": "void",
    "function_definition": "CREATE OR REPLACE FUNCTION public.sync_movements_from_library()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nBEGIN\n  -- Upsert into public.movements from the materialized view\n  INSERT INTO public.movements AS m (id, name, description, video_url, joints_impacted, muscles_impacted, super_metrics_impacted)\n  SELECT id, name, description, video_url, joints_impacted, muscles_impacted, super_metrics_impacted\n  FROM public.movement_library\n  ON CONFLICT (id) DO UPDATE SET\n    name = EXCLUDED.name,\n    description = EXCLUDED.description,\n    video_url = EXCLUDED.video_url,\n    joints_impacted = EXCLUDED.joints_impacted,\n    muscles_impacted = EXCLUDED.muscles_impacted,\n    super_metrics_impacted = EXCLUDED.super_metrics_impacted;\nEND$function$\n",
    "source_code": "\nBEGIN\n  -- Upsert into public.movements from the materialized view\n  INSERT INTO public.movements AS m (id, name, description, video_url, joints_impacted, muscles_impacted, super_metrics_impacted)\n  SELECT id, name, description, video_url, joints_impacted, muscles_impacted, super_metrics_impacted\n  FROM public.movement_library\n  ON CONFLICT (id) DO UPDATE SET\n    name = EXCLUDED.name,\n    description = EXCLUDED.description,\n    video_url = EXCLUDED.video_url,\n    joints_impacted = EXCLUDED.joints_impacted,\n    muscles_impacted = EXCLUDED.muscles_impacted,\n    super_metrics_impacted = EXCLUDED.super_metrics_impacted;\nEND"
  },
  {
    "schema_name": "public",
    "function_name": "tg_set_timestamp",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.tg_set_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  NEW.updated_at = now();\n  RETURN NEW;\nEND;\n$function$\n",
    "source_code": "\nBEGIN\n  NEW.updated_at = now();\n  RETURN NEW;\nEND;\n"
  },
  {
    "schema_name": "public",
    "function_name": "tg_touch_block_updated_at",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.tg_touch_block_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  v_block_id uuid;\nBEGIN\n  v_block_id := COALESCE(NEW.block_id, OLD.block_id);\n  UPDATE public.movement_blocks\n     SET updated_at = now()\n   WHERE id = v_block_id;\n  RETURN NULL; -- statement-level effect; row image not needed\nEND;\n$function$\n",
    "source_code": "\nDECLARE\n  v_block_id uuid;\nBEGIN\n  v_block_id := COALESCE(NEW.block_id, OLD.block_id);\n  UPDATE public.movement_blocks\n     SET updated_at = now()\n   WHERE id = v_block_id;\n  RETURN NULL; -- statement-level effect; row image not needed\nEND;\n"
  },
  {
    "schema_name": "public",
    "function_name": "trg_validate_program_workout_at_commit",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.trg_validate_program_workout_at_commit()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n  perform public.validate_single_program_workout(NEW.id);\n  return NEW;\nend;\n$function$\n",
    "source_code": "\nbegin\n  perform public.validate_single_program_workout(NEW.id);\n  return NEW;\nend;\n"
  },
  {
    "schema_name": "public",
    "function_name": "trg_validate_program_workout_blocks",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.trg_validate_program_workout_blocks()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\ndeclare\n  v_program_workout_id uuid;\nbegin\n  v_program_workout_id := coalesce(NEW.program_workout_id, OLD.program_workout_id);\n  perform public.validate_single_program_workout(v_program_workout_id);\n  return null;\nend;\n$function$\n",
    "source_code": "\ndeclare\n  v_program_workout_id uuid;\nbegin\n  v_program_workout_id := coalesce(NEW.program_workout_id, OLD.program_workout_id);\n  perform public.validate_single_program_workout(v_program_workout_id);\n  return null;\nend;\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_updated_at_column",
    "arguments": "",
    "return_type": "trigger",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'public', 'public'\nAS $function$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$function$\n",
    "source_code": "\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n"
  },
  {
    "schema_name": "public",
    "function_name": "validate_single_program_workout",
    "arguments": "p_program_workout_id uuid",
    "return_type": "void",
    "function_definition": "CREATE OR REPLACE FUNCTION public.validate_single_program_workout(p_program_workout_id uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\ndeclare\n  v_total_blocks int;\n  v_distinct_buckets int;\n  v_unknown int;\nbegin\n  -- must have exactly 4 blocks\n  select count(*)\n    into v_total_blocks\n  from public.program_workout_blocks pwb\n  where pwb.program_workout_id = p_program_workout_id;\n\n  if v_total_blocks <> 4 then\n    raise exception\n      'program_workout % must have exactly 4 blocks (found %).',\n      p_program_workout_id, v_total_blocks\n      using errcode = '23514';\n  end if;\n\n  -- map block_types.label  canonical buckets\n  with buckets as (\n    select\n      case\n        when lower(bt.label) in ('warm-up','warm up','warmup') then 'warmup'\n        when lower(bt.label) in ('strength & conditioning','strength and conditioning') then 'sc'\n        when lower(bt.label) = 'aerobic' then 'aerobic'\n        when lower(bt.label) in ('cooldown','cool down','cool-down') then 'cooldown'\n        else null\n      end as bucket\n    from public.program_workout_blocks pwb\n    join public.movement_blocks mb on mb.id = pwb.movement_block_id\n    join public.block_types bt      on bt.id = mb.block_type_id\n    where pwb.program_workout_id = p_program_workout_id\n  )\n  select\n    count(distinct bucket),\n    count(*) filter (where bucket is null)\n  into v_distinct_buckets, v_unknown\n  from buckets;\n\n  if v_unknown > 0 then\n    raise exception\n      'program_workout % contains % block(s) with unknown block_types.label.',\n      p_program_workout_id, v_unknown\n      using errcode = '23514';\n  end if;\n\n  if v_distinct_buckets <> 4 then\n    raise exception\n      'program_workout % must include exactly one of each: warmup, sc, aerobic, cooldown (found % distinct).',\n      p_program_workout_id, v_distinct_buckets\n      using errcode = '23514';\n  end if;\nend;\n$function$\n",
    "source_code": "\ndeclare\n  v_total_blocks int;\n  v_distinct_buckets int;\n  v_unknown int;\nbegin\n  -- must have exactly 4 blocks\n  select count(*)\n    into v_total_blocks\n  from public.program_workout_blocks pwb\n  where pwb.program_workout_id = p_program_workout_id;\n\n  if v_total_blocks <> 4 then\n    raise exception\n      'program_workout % must have exactly 4 blocks (found %).',\n      p_program_workout_id, v_total_blocks\n      using errcode = '23514';\n  end if;\n\n  -- map block_types.label  canonical buckets\n  with buckets as (\n    select\n      case\n        when lower(bt.label) in ('warm-up','warm up','warmup') then 'warmup'\n        when lower(bt.label) in ('strength & conditioning','strength and conditioning') then 'sc'\n        when lower(bt.label) = 'aerobic' then 'aerobic'\n        when lower(bt.label) in ('cooldown','cool down','cool-down') then 'cooldown'\n        else null\n      end as bucket\n    from public.program_workout_blocks pwb\n    join public.movement_blocks mb on mb.id = pwb.movement_block_id\n    join public.block_types bt      on bt.id = mb.block_type_id\n    where pwb.program_workout_id = p_program_workout_id\n  )\n  select\n    count(distinct bucket),\n    count(*) filter (where bucket is null)\n  into v_distinct_buckets, v_unknown\n  from buckets;\n\n  if v_unknown > 0 then\n    raise exception\n      'program_workout % contains % block(s) with unknown block_types.label.',\n      p_program_workout_id, v_unknown\n      using errcode = '23514';\n  end if;\n\n  if v_distinct_buckets <> 4 then\n    raise exception\n      'program_workout % must include exactly one of each: warmup, sc, aerobic, cooldown (found % distinct).',\n      p_program_workout_id, v_distinct_buckets\n      using errcode = '23514';\n  end if;\nend;\n"
  }
]