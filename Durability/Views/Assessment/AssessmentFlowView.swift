import SwiftUI

struct AssessmentFlowView: View {
    @EnvironmentObject var appState: AppState
    @StateObject private var viewModel = AssessmentViewModel()
    
    // Use AppState results if available, otherwise use view model results
    private var assessmentResults: [AssessmentResult] {
        return appState.currentAssessmentResults.isEmpty ? viewModel.assessmentResults : appState.currentAssessmentResults
    }
    
    var body: some View {
        NavigationStack {
            VStack {
                if viewModel.isLoading {
                    LoadingView()
                } else if viewModel.showingInstructions {
                    AssessmentInstructionsView(viewModel: viewModel)
                } else if viewModel.isRecording {
                    AssessmentRecordingView(viewModel: viewModel)
                } else if viewModel.showingResults || appState.appFlowState == .assessmentResults {
                    AssessmentResultsView(viewModel: viewModel, assessmentResults: assessmentResults)
                } else {
                    AssessmentStartView(viewModel: viewModel)
                }
            }
            .background(Color.darkSpaceGrey)
            .navigationTitle("Movement Assessment")
            .navigationBarTitleDisplayMode(.inline)
        }
        .background(Color.darkSpaceGrey)
        .onAppear {
            // View appeared
        }
    }
}

@MainActor
class AssessmentViewModel: ObservableObject {
    @Published var isLoading = false
    @Published var showingInstructions = false
    @Published var isRecording = false
    @Published var showingResults = false
    @Published var recordingTime: TimeInterval = 0
    @Published var assessmentResults: [AssessmentResult] = []
    @Published var errorMessage: String?
    @Published var isCameraPresented = false
    @Published var videoURL: URL?

    private var timer: Timer?

    func startAssessment() {
        showingInstructions = true
    }

    func beginRecording() {
        isRecording = true
        showingInstructions = false
        // The camera is now presented from the view
    }

    func stopRecording(appState: AppState) {
        isRecording = false
        isCameraPresented = false
        generateResults(appState: appState)
    }
    
    private func generateResults(appState: AppState) {
        isLoading = true
        
        Task {
            guard let userId = appState.authService.user?.id.uuidString else {
                errorMessage = "User not authenticated"
                isLoading = false
                return
            }
            
            do {
                var assessment: Assessment?
                
                // Always create a new assessment record (even for retakes)
                // This ensures we have a complete history of all assessments
                if let videoURL = videoURL {
                    assessment = try await appState.assessmentService.createAssessmentWithVideo(
                        profileId: userId,
                        videoURL: videoURL
                    )
                } else {
                    assessment = try await appState.assessmentService.createAssessmentWithoutVideo(
                        profileId: userId
                    )
                }
                
                guard let assessment = assessment else {
                    errorMessage = "Failed to create assessment record"
                    isLoading = false
                    return
                }

                // Simulate assessment processing
                try await Task.sleep(nanoseconds: 2_000_000_000) // 2 seconds

                // Generate assessment results for different body areas
                let bodyAreas = ["Overall", "Shoulder", "Torso", "Hips", "Knees", "Ankles", "Elbows"]
                var results: [AssessmentResult] = []

                for area in bodyAreas {
                    let result = AssessmentResult(
                        id: nil, // Will be auto-generated by database
                        assessmentId: assessment.assessmentId!, // Use the integer assessment ID
                        profileId: userId, // Use the user's profile ID
                        bodyArea: area,
                        durabilityScore: Double.random(in: 0.6...0.9),
                        rangeOfMotionScore: Double.random(in: 0.5...0.9),
                        flexibilityScore: Double.random(in: 0.4...0.8),
                        functionalStrengthScore: Double.random(in: 0.6...0.9),
                        mobilityScore: Double.random(in: 0.5...0.8),
                        aerobicCapacityScore: Double.random(in: 0.7...0.9)
                    )
                    
                    results.append(result)
                }

                // Always create new assessment results (even for retakes)
                // This ensures we have fresh data for each assessment attempt
                do {
                    try await appState.assessmentService.createAssessmentResults(
                        assessmentId: assessment.assessmentId!,
                        results: results
                    )
                } catch {
                    // Continue with the flow even if database write fails
                    // The results are still generated and can be displayed
                }

                assessmentResults = results
                isLoading = false
                showingResults = true
                
                // Store results in AppState and set the app state to show assessment results
                await MainActor.run {
                    appState.currentAssessmentResults = results
                    appState.appFlowState = .assessmentResults
                }
                
            } catch {
                errorMessage = "Failed to process assessment: \(error.localizedDescription)"
                isLoading = false
            }
        }
    }

    
    func completeAssessment(appState: AppState) {
        Task {
            guard appState.authService.user?.id.uuidString != nil else {
                return
            }
            
            do {
                // Update user profile to mark assessment as completed
                var updatedProfile = appState.currentUser
                updatedProfile?.assessmentCompleted = true
                updatedProfile?.updatedAt = Date()
                
                if let profile = updatedProfile {
                    try await appState.profileService.updateProfile(profile)
                    print("üîç AssessmentFlowView: Profile updated with assessmentCompleted: \(profile.assessmentCompleted)")
                    
                    // Update app state to move to main app
                    await MainActor.run {
                        appState.currentUser = profile
                        appState.appFlowState = .mainApp
                        print("üîç AssessmentFlowView: Set appState.assessmentCompleted = true")
                    }
                }
            } catch {
                // Even if database update fails, try to advance to main app
                await MainActor.run {
                    appState.appFlowState = .mainApp
                }
            }
        }
    }
    
    /// Reset the view model state to start a new assessment
    func resetForNewAssessment() {
        showingResults = false
        showingInstructions = false
        isRecording = false
        assessmentResults = []
        videoURL = nil
        errorMessage = nil
        recordingTime = 0
        isCameraPresented = false
    }
}

struct AssessmentStartView: View {
    @ObservedObject var viewModel: AssessmentViewModel
    
    var body: some View {
        VStack(spacing: 30) {
            Spacer()
            
            Image(systemName: "figure.walk")
                .font(.system(size: 80))
                .foregroundColor(.electricGreen)
            
            Text("Movement Assessment")
                .font(.title)
                .fontWeight(.bold)
                .foregroundColor(.lightText)
            
            Text("We'll assess your movement patterns to create a personalized training plan.")
                .font(.body)
                .multilineTextAlignment(.center)
                .foregroundColor(.secondaryText)
                .padding(.horizontal)
            
            VStack(alignment: .leading, spacing: 15) {
                Text("The assessment includes:")
                    .font(.headline)
                    .foregroundColor(.lightText)
                
                VStack(alignment: .leading, spacing: 8) {
                    AssessmentStepRow(number: "1", text: "Overhead Squat")
                    AssessmentStepRow(number: "2", text: "Active Straight Leg Raise")
                    AssessmentStepRow(number: "3", text: "Shoulder Raise")
                    AssessmentStepRow(number: "4", text: "Standing Hip Hinge")
                    AssessmentStepRow(number: "5", text: "Child's Pose")
                    AssessmentStepRow(number: "6", text: "Cobra")
                }
            }
            .padding()
            .background(Color.lightSpaceGrey)
            .cornerRadius(15)
            
            Button(action: {
                viewModel.startAssessment()
            }) {
                Text("Start Assessment")
                    .fontWeight(.semibold)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.electricGreen)
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
            
            Spacer()
        }
        .padding()
        .background(Color.darkSpaceGrey)
    }
}

struct AssessmentStepRow: View {
    let number: String
    let text: String
    
    var body: some View {
        HStack {
            Text(number)
                .font(.caption)
                .fontWeight(.bold)
                .foregroundColor(.white)
                .frame(width: 20, height: 20)
                .background(Color.electricGreen)
                .clipShape(Circle())
            
            Text(text)
                .font(.subheadline)
                .foregroundColor(.lightText)
            
            Spacer()
        }
    }
}

#Preview {
    AssessmentFlowView()
        .environmentObject(AppState())
}
