import SwiftUI

struct AssessmentFlowView: View {
    @EnvironmentObject var appState: AppState
    @StateObject private var viewModel = AssessmentViewModel()
    
    // Use AppState results if available, otherwise use view model results
    private var assessmentResults: [AssessmentResult] {
        return appState.currentAssessmentResults.isEmpty ? viewModel.assessmentResults : appState.currentAssessmentResults
    }
    
    var body: some View {
        NavigationStack {
            VStack {
                if viewModel.isLoading {
                    LoadingView()
                } else if viewModel.showingInstructions {
                    AssessmentInstructionsView(viewModel: viewModel)
                } else if viewModel.isRecording {
                    AssessmentRecordingView(viewModel: viewModel)
                } else if viewModel.showingResults || appState.appFlowState == .assessmentResults {
                    AssessmentResultsView(viewModel: viewModel, assessmentResults: assessmentResults)
                } else {
                    AssessmentStartView(viewModel: viewModel)
                }
            }
            .background(Color.darkSpaceGrey)
            .navigationTitle("Movement Assessment")
            .navigationBarTitleDisplayMode(.inline)
        }
        .background(Color.darkSpaceGrey)
        .onAppear {
            // View appeared
        }
    }
}

@MainActor
class AssessmentViewModel: ObservableObject {
    @Published var isLoading = false
    @Published var isCompletingAssessment = false // New state for assessment completion
    @Published var showingInstructions = false
    @Published var isRecording = false
    @Published var showingResults = false
    @Published var recordingTime: TimeInterval = 0
    @Published var assessmentResults: [AssessmentResult] = []
    @Published var errorMessage: String?
    @Published var isCameraPresented = false
    @Published var videoURL: URL?

    private var timer: Timer?

    func startAssessment() {
        showingInstructions = true
    }

    func beginRecording() {
        isRecording = true
        showingInstructions = false
        // The camera is now presented from the view
    }

    func stopRecording(appState: AppState) {
        isRecording = false
        isCameraPresented = false
        generateResults(appState: appState)
    }
    
    private func generateResults(appState: AppState) {
        // Generate results immediately for display
        let bodyAreas = ["Overall", "Shoulder", "Torso", "Hips", "Knees", "Ankles", "Elbows"]
        var results: [AssessmentResult] = []

        for area in bodyAreas {
            let result = AssessmentResult(
                id: nil, // Will be auto-generated by database
                assessmentId: nil, // Will be set after database creation
                profileId: appState.authService.user?.id.uuidString ?? "", // Use the user's profile ID
                bodyArea: area,
                durabilityScore: Double.random(in: 0.1...0.9),
                rangeOfMotionScore: Double.random(in: 0.1...0.9),
                flexibilityScore: Double.random(in: 0.1...0.8),
                functionalStrengthScore: Double.random(in: 0.1...0.9),
                mobilityScore: Double.random(in: 0.1...0.8),
                aerobicCapacityScore: Double.random(in: 0.1...0.9)
            )
            
            results.append(result)
        }

        // Display results immediately
        assessmentResults = results
        showingResults = true
        
        // Store results in AppState and set the app state to show assessment results
        Task { @MainActor in
            appState.currentAssessmentResults = results
            appState.appFlowState = .assessmentResults
        }
        
        // Handle database operations asynchronously in the background
        Task {
            guard let userId = appState.authService.user?.id.uuidString else {
                return
            }
            
            do {
                var assessment: Assessment?
                
                // Create assessment record in background
                if let videoURL = videoURL {
                    assessment = try await appState.assessmentService.createAssessmentWithVideo(
                        profileId: userId,
                        videoURL: videoURL
                    )
                } else {
                    assessment = try await appState.assessmentService.createAssessmentWithoutVideo(
                        profileId: userId
                    )
                }
                
                guard let assessment = assessment else {
                    return
                }

                // Update results with the actual assessment ID
                var updatedResults = results
                for i in 0..<updatedResults.count {
                    updatedResults[i].assessmentId = assessment.assessmentId
                }

                // Create assessment results in database
                guard let assessmentId = assessment.assessmentId else {
                    print("Assessment ID is nil, cannot create results")
                    return
                }
                
                try await appState.assessmentService.createAssessmentResults(
                    assessmentId: assessmentId,
                    results: updatedResults
                )
                
                // Update the stored results with the database IDs
                await MainActor.run {
                    self.assessmentResults = updatedResults
                    appState.currentAssessmentResults = updatedResults
                }
                
            } catch {
                // Log error but don't affect user experience
                print("Background database operation failed: \(error.localizedDescription)")
            }
        }
    }

    
    func completeAssessment(appState: AppState) {
        // Show loading state for profile update
        isCompletingAssessment = true
        
        Task {
            guard appState.authService.user?.id.uuidString != nil else {
                await MainActor.run {
                    isCompletingAssessment = false
                }
                return
            }
            
            do {
                // Update user profile to mark assessment as completed
                var updatedProfile = appState.currentUser
                updatedProfile?.assessmentCompleted = true
                updatedProfile?.updatedAt = Date()
                
                if let profile = updatedProfile {
                    try await appState.profileService.updateProfile(profile)
                    
                    // Update app state to move to main app
                    await MainActor.run {
                        appState.currentUser = profile
                        appState.appFlowState = .mainApp
                        isCompletingAssessment = false
                    }
                } else {
                    await MainActor.run {
                        isCompletingAssessment = false
                    }
                }
            } catch {
                // Even if database update fails, try to advance to main app
                await MainActor.run {
                    appState.appFlowState = .mainApp
                    isCompletingAssessment = false
                }
            }
        }
    }
    
    /// Reset the view model state to start a new assessment
    func resetForNewAssessment() {
        showingResults = false
        showingInstructions = false
        isRecording = false
        assessmentResults = []
        videoURL = nil
        errorMessage = nil
        recordingTime = 0
        isCameraPresented = false
    }
}

struct AssessmentStartView: View {
    @ObservedObject var viewModel: AssessmentViewModel
    @EnvironmentObject var appState: AppState
    
    var body: some View {
        VStack(spacing: 30) {
            Spacer()
            
            Image(systemName: "figure.walk")
                .font(.system(size: 80))
                .foregroundColor(.electricGreen)
            
            Text("Movement Assessment")
                .font(.title)
                .fontWeight(.bold)
                .foregroundColor(.lightText)
            
            Text("We'll assess your movement patterns to create a personalized training plan.")
                .font(.body)
                .multilineTextAlignment(.center)
                .foregroundColor(.secondaryText)
                .padding(.horizontal)
            
            VStack(alignment: .leading, spacing: 15) {
                Text("The assessment includes:")
                    .font(.headline)
                    .foregroundColor(.lightText)
                
                VStack(alignment: .leading, spacing: 8) {
                    AssessmentStepRow(number: "1", text: "Overhead Squat")
                    AssessmentStepRow(number: "2", text: "Active Straight Leg Raise")
                    AssessmentStepRow(number: "3", text: "Shoulder Raise")
                    AssessmentStepRow(number: "4", text: "Standing Hip Hinge")
                    AssessmentStepRow(number: "5", text: "Child's Pose")
                    AssessmentStepRow(number: "6", text: "Cobra")
                }
            }
            .padding()
            .background(Color.lightSpaceGrey)
            .cornerRadius(15)
            
            VStack(spacing: 12) {
                Button(action: {
                    viewModel.startAssessment()
                }) {
                    Text("Start Assessment")
                        .fontWeight(.semibold)
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.electricGreen)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
                
                Button(action: {
                    appState.appFlowState = .mainApp
                }) {
                    Text("Back to Home")
                        .fontWeight(.semibold)
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.clear)
                        .foregroundColor(.secondaryText)
                        .overlay(
                            RoundedRectangle(cornerRadius: 10)
                                .stroke(Color.secondaryText, lineWidth: 1)
                        )
                }
            }
            
            Spacer()
        }
        .padding()
        .background(Color.darkSpaceGrey)
    }
}

struct AssessmentStepRow: View {
    let number: String
    let text: String
    
    var body: some View {
        HStack {
            Text(number)
                .font(.caption)
                .fontWeight(.bold)
                .foregroundColor(.white)
                .frame(width: 20, height: 20)
                .background(Color.electricGreen)
                .clipShape(Circle())
            
            Text(text)
                .font(.subheadline)
                .foregroundColor(.lightText)
            
            Spacer()
        }
    }
}

#Preview {
    AssessmentFlowView()
        .environmentObject(AppState())
}
